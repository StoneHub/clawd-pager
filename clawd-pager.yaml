esphome:
  name: clawd-pager
  friendly_name: "Clawd Pager"
  includes:
    - audio_streamer.h
  on_boot:
    priority: -10
    then:
      - rtttl.play: "Startup:d=4,o=5,b=180:c,e,g,c6"
      - text_sensor.template.publish:
          id: pager_display
          state: "CLAWDBOT READY"
      - text_sensor.template.publish:
          id: display_mode
          state: "IDLE"
      - text_sensor.template.publish:
          id: weather_display
          state: ""
      - lambda: |-
          // Initialize audio streamer with bridge IP and port
          audio_streamer().begin("192.168.50.50", 12345);

esp32:
  board: m5stick-c
  framework:
    type: arduino

external_components:
  # Using makerwolf fork for charging detection support
  - source: github://makerwolf/esphome-axp192
    components: [axp192]

i2c:
  sda: 21
  scl: 22

# I2S Audio for PDM microphone (SPM1423)
# M5StickC Plus 1.1: CLK=GPIO0, Data=GPIO34
# NOTE: Buzzer must be OFF during recording - they share resources!
i2s_audio:
  - id: mic_i2s_bus
    i2s_lrclk_pin:
      number: GPIO0
      ignore_strapping_warning: true

microphone:
  - platform: i2s_audio
    id: mic_i2s
    i2s_audio_id: mic_i2s_bus
    i2s_din_pin: GPIO34
    adc_type: external
    pdm: true
    channel: left
    on_data:
      - lambda: |-
          // Stream audio via UDP to bridge when recording
          if (id(is_recording) && x.size() > 0) {
            audio_streamer().send_audio(x.data(), x.size());
          }

logger:
  level: DEBUG

api:
  services:
    # Main display update service - called by bridge
    - service: set_display
      variables:
        my_text: string
        my_mode: string
      then:
        - text_sensor.template.publish:
            id: pager_display
            state: !lambda "return my_text;"
        - text_sensor.template.publish:
            id: display_mode
            state: !lambda "return my_mode;"
        - if:
            condition:
              lambda: 'return my_mode != "SILENT";'
            then:
              - rtttl.play: "Blip:d=32,o=6,b=150:c6"
        - script.execute: activity_watcher
    
    # Weather widget update
    - service: update_weather
      variables:
        my_weather: string
      then:
        - text_sensor.template.publish:
            id: weather_display
            state: !lambda "return my_weather;"
    
    # Alert with distinct tone
    - service: alert
      variables:
        my_text: string
      then:
        - rtttl.play: "Alert:d=16,o=6,b=180:c,e,g,c7"
        - text_sensor.template.publish:
            id: pager_display
            state: !lambda "return my_text;"
        - text_sensor.template.publish:
            id: display_mode
            state: "ALERT"
        - script.execute: activity_watcher
        - lambda: |-
            if (id(dev_mode)) {
              id(event_seq)++;
              ESP_LOGI("EVENT", "[%d] ALERT | text=%s", id(event_seq), my_text.c_str());
            }

    # Toggle development mode (verbose logging)
    - service: set_dev_mode
      variables:
        enabled: bool
      then:
        - globals.set:
            id: dev_mode
            value: !lambda "return enabled;"
        - lambda: |-
            ESP_LOGI("EVENT", "DEV_MODE %s", enabled ? "ENABLED" : "DISABLED");

    # Get current device state (for dashboard polling)
    - service: get_state
      then:
        - lambda: |-
            ESP_LOGI("STATE", "mode=%s battery=%.0f dev_mode=%s",
                     id(display_mode).state.c_str(),
                     id(battery_level).has_state() ? id(battery_level).state : 0.0,
                     id(dev_mode) ? "true" : "false");

ota:
  - platform: esphome

wifi:
  ssid: "FlyingChanges"
  password: "flyingchanges"
  fast_connect: true
  power_save_mode: none

time:
  - platform: sntp
    id: sntp_time
    timezone: "EST5EDT,M3.2.0,M11.1.0"

output:
  - platform: ledc
    id: buzzer_pwm
    pin: GPIO2

rtttl:
  output: buzzer_pwm
  id: buzzer

sensor:
  - platform: axp192
    model: M5STICKC
    address: 0x34
    id: my_axp
    battery_level:
      name: "Battery"
      id: battery_level

binary_sensor:
  # Charging detection via template - polls AXP192 charging status
  - platform: template
    name: "Charging"
    id: is_charging
    lambda: |-
      // Check if battery is charging by comparing voltage/current
      // AXP192 reports charging when VBUS is present and battery < 100%
      return id(battery_level).state < 99.0;
    on_press:
      then:
        - lambda: |-
            if (id(dev_mode)) {
              id(event_seq)++;
              ESP_LOGI("EVENT", "[%d] CHARGING_START", id(event_seq));
            }
            // Full brightness when charging - we have power!
            id(my_axp).set_brightness(1.0);
        - if:
            condition:
              lambda: 'return id(display_mode).state == "IDLE";'
            then:
              - text_sensor.template.publish:
                  id: display_mode
                  state: "DOCKED"
    on_release:
      then:
        - lambda: |-
            if (id(dev_mode)) {
              id(event_seq)++;
              ESP_LOGI("EVENT", "[%d] CHARGING_STOP", id(event_seq));
            }
        - if:
            condition:
              lambda: 'return id(display_mode).state == "DOCKED";'
            then:
              - text_sensor.template.publish:
                  id: display_mode
                  state: "IDLE"

  # Button A - Briefing / Sleep countdown
  - platform: gpio
    pin:
      number: GPIO37
      inverted: true
    name: "Button A"
    id: button_a
    on_press:
      then:
        - rtttl.play: "Blip:d=32,o=6,b=150:c6"
        - globals.set:
            id: btn_a_pressed
            value: 'true'
        - script.execute: activity_watcher
        - lambda: |-
            if (id(dev_mode)) {
              id(event_seq)++;
              ESP_LOGI("EVENT", "[%d] BUTTON_A_PRESS | mode=%s", id(event_seq), id(display_mode).state.c_str());
            }
    on_release:
      then:
        - globals.set:
            id: btn_a_pressed
            value: 'false'
        - lambda: |-
            if (id(dev_mode)) {
              id(event_seq)++;
              ESP_LOGI("EVENT", "[%d] BUTTON_A_RELEASE", id(event_seq));
            }

  # Button B - Voice / Home
  - platform: gpio
    pin:
      number: GPIO39
      inverted: true
    name: "Button B"
    id: button_b
    on_multi_click:
      # Short tap (< 400ms) = Go home / Cancel
      - timing:
          - ON for at most 400ms
          - OFF for at least 50ms
        then:
          - rtttl.play: "Back:d=32,o=5,b=150:c"
          - lambda: |-
              if (id(dev_mode)) {
                id(event_seq)++;
                ESP_LOGI("EVENT", "[%d] BUTTON_B_TAP | action=HOME", id(event_seq));
              }
          - text_sensor.template.publish:
              id: display_mode
              state: "IDLE"
          - text_sensor.template.publish:
              id: pager_display
              state: "CLAWDBOT READY"
          - script.execute: activity_watcher
      # Long hold (> 400ms) = Voice recording
      - timing:
          - ON for at least 400ms
        then:
          - rtttl.play: "Voice:d=32,o=6,b=150:g,c7"
          - delay: 100ms
          # CRITICAL: Stop buzzer before recording - they share resources!
          - output.turn_off: buzzer_pwm
          - globals.set:
              id: btn_b_pressed
              value: 'true'
          - globals.set:
              id: is_recording
              value: 'true'
          - text_sensor.template.publish:
              id: display_mode
              state: "LISTENING"
          - text_sensor.template.publish:
              id: pager_display
              state: "LISTENING..."
          - script.execute: activity_watcher
          - lambda: |-
              // Start audio streaming
              audio_streamer().start_recording();
              if (id(dev_mode)) {
                id(event_seq)++;
                ESP_LOGI("EVENT", "[%d] BUTTON_B_HOLD | mode=LISTENING | streaming=started", id(event_seq));
              }
          # Start microphone capture
          - microphone.capture: mic_i2s
    on_release:
      then:
        - if:
            condition:
              lambda: 'return id(btn_b_pressed);'
            then:
              # Stop microphone first
              - microphone.stop_capture: mic_i2s
              - lambda: |-
                  // Stop audio streaming
                  id(is_recording) = false;
                  audio_streamer().stop_recording();
                  ESP_LOGI("AUDIO", "Sent %d bytes", audio_streamer().bytes_sent());
              - rtttl.play: "Done:d=32,o=6,b=150:c"
              - globals.set:
                  id: btn_b_pressed
                  value: 'false'
              - text_sensor.template.publish:
                  id: display_mode
                  state: "PROCESSING"
              - text_sensor.template.publish:
                  id: pager_display
                  state: "PROCESSING..."
              - lambda: |-
                  if (id(dev_mode)) {
                    id(event_seq)++;
                    ESP_LOGI("EVENT", "[%d] BUTTON_B_RELEASE | mode=PROCESSING | bytes=%d", id(event_seq), audio_streamer().bytes_sent());
                  }

  # Power Button - Toggle brightness
  - platform: gpio
    pin:
      number: GPIO35
      inverted: true
    name: "Power Button"
    on_click:
      min_length: 50ms
      max_length: 500ms
      then:
        - lambda: |-
            id(screen_bright) = !id(screen_bright);
            id(my_axp).set_brightness(id(screen_bright) ? 1.0 : 0.2);

# Text sensors - exposed to bridge
text_sensor:
  - platform: template
    id: pager_display
    name: "Pager Display"
  - platform: template
    id: weather_display
    name: "Weather Display"
  - platform: template
    id: display_mode
    name: "Display Mode"

globals:
  - id: pulse_state
    type: bool
    initial_value: 'false'
  - id: btn_a_pressed
    type: bool
    initial_value: 'false'
  - id: btn_b_pressed
    type: bool
    initial_value: 'false'
  - id: screen_bright
    type: bool
    initial_value: 'true'
  # Development mode - enables verbose event logging
  - id: dev_mode
    type: bool
    initial_value: 'true'
  # Event sequence counter for ordering
  - id: event_seq
    type: int
    initial_value: '0'
  # Audio recording state
  - id: is_recording
    type: bool
    initial_value: 'false'

script:
  - id: activity_watcher
    mode: restart
    then:
      - lambda: |-
          id(my_axp).set_brightness(1.0);
      - delay: 30s
      - lambda: |-
          // Don't dim if charging/docked - we have power!
          if (id(display_mode).state != "DOCKED") {
            id(my_axp).set_brightness(0.4);
          }
      - delay: 30s
      - lambda: |-
          // Don't dim if charging/docked
          if (id(display_mode).state != "DOCKED") {
            id(my_axp).set_brightness(0.1);
          }

spi:
  clk_pin: GPIO13
  mosi_pin: GPIO15

display:
  - platform: st7789v
    model: TTGO_TDisplay_135x240
    cs_pin: GPIO5
    dc_pin: GPIO23
    reset_pin: GPIO18
    rotation: 270
    update_interval: 0.5s
    lambda: |-
      // === COLOR PALETTE ===
      Color CYAN = Color(0, 255, 255);
      Color TEAL = Color(0, 200, 200);
      Color CORAL = Color(255, 127, 80);
      Color AMBER = Color(255, 191, 0);
      Color LIME = Color(50, 205, 50);
      Color PINK = Color(255, 105, 180);
      Color PURPLE = Color(147, 112, 219);
      Color RED = Color(255, 60, 60);
      Color ORANGE = Color(255, 140, 0);
      Color DIM = Color(100, 100, 100);

      it.fill(Color::BLACK);
      id(pulse_state) = !id(pulse_state);
      int frame = (millis() / 100) % 20;  // Animation frame

      std::string mode = id(display_mode).state;
      std::string msg = id(pager_display).state;

      // === LISTENING MODE - Cyan waveform ===
      if (mode == "LISTENING") {
          // Gradient header bar
          it.filled_rectangle(0, 0, 240, 25, TEAL);
          it.print(120, 5, id(font_body), Color::BLACK, TextAlign::TOP_CENTER, "LISTENING");

          // Animated audio waveform - bouncing bars
          for (int i = 0; i < 12; i++) {
            int phase = (frame + i * 2) % 20;
            int h = 8 + abs(10 - phase) * 2;
            Color bar_color = (i % 2 == 0) ? CYAN : TEAL;
            it.filled_rectangle(30 + i * 16, 70 - h, 10, h * 2, bar_color);
          }

          it.print(120, 115, id(font_small), DIM, TextAlign::CENTER, "Release when done");
          return;
      }

      // === PROCESSING MODE - Amber spinner ===
      if (mode == "PROCESSING") {
          it.print(120, 35, id(font_body), AMBER, TextAlign::CENTER, "PROCESSING");

          // Spinning dots animation
          for (int i = 0; i < 8; i++) {
            float angle = (i * 45 + frame * 18) * 3.14159 / 180;
            int x = 120 + cos(angle) * 25;
            int y = 80 + sin(angle) * 25;
            int size = (i == (frame % 8)) ? 6 : 3;
            Color dot_color = (i == (frame % 8)) ? AMBER : ORANGE;
            it.filled_circle(x, y, size, dot_color);
          }

          it.print(120, 115, id(font_small), DIM, TextAlign::CENTER, "Thinking...");
          return;
      }

      // === AWAITING MODE - Purple pulse ===
      if (mode == "AWAITING") {
          it.print(120, 35, id(font_body), PURPLE, TextAlign::CENTER, "AWAITING");
          it.print(120, 55, id(font_body), PURPLE, TextAlign::CENTER, "RESPONSE");

          // Pulsing concentric circles
          int pulse_size = 5 + (frame % 10) * 2;
          it.circle(120, 95, pulse_size, PURPLE);
          it.circle(120, 95, pulse_size + 8, PINK);
          if (id(pulse_state)) {
            it.filled_circle(120, 95, 4, PURPLE);
          }
          return;
      }

      // === DOCKED MODE - Ambient display when charging ===
      if (mode == "DOCKED") {
          // Dark ambient background with floating particles
          int slow_frame = (millis() / 200) % 100;

          // Orbiting particles around center
          for (int i = 0; i < 6; i++) {
            float angle = (i * 60 + slow_frame * 3.6) * 3.14159 / 180;
            int radius = 35 + (i % 2) * 15;
            int x = 120 + cos(angle) * radius;
            int y = 68 + sin(angle) * (radius / 2);  // Elliptical orbit
            Color particle_color = (i % 3 == 0) ? CYAN : ((i % 3 == 1) ? PURPLE : PINK);
            int size = 2 + (slow_frame + i * 16) % 3;
            it.filled_circle(x, y, size, particle_color);
          }

          // Gentle clock in center
          it.strftime(120, 50, id(font_large), CYAN, TextAlign::CENTER, "%H:%M", id(sntp_time).now());

          // Subtle "DOCKED" indicator
          it.print(120, 95, id(font_small), DIM, TextAlign::CENTER, "DOCKED");

          // Charging indicator - animated lightning bolt effect
          int bolt_y = 115 + (slow_frame % 10 < 5 ? 0 : 2);
          it.print(110, bolt_y, id(font_small), LIME, TextAlign::CENTER, "++");

          // Battery with fill animation
          if (id(battery_level).has_state()) {
            float batt = id(battery_level).state;
            int fill = (int)(batt / 100.0 * 30) + (slow_frame % 5);
            if (fill > 30) fill = 30;
            it.rectangle(105, 125, 30, 8, LIME);
            it.filled_rectangle(105, 125, fill, 8, LIME);
            it.printf(140, 125, id(font_small), LIME, "%.0f%%", batt);
          }
          return;
      }

      // === QUESTION MODE - Claude Code is asking something ===
      if (mode == "QUESTION") {
          int pulse_frame = (millis() / 300) % 10;

          // Attention-getting header
          Color question_color = id(pulse_state) ? AMBER : ORANGE;
          it.filled_rectangle(0, 0, 240, 25, question_color);
          it.print(120, 5, id(font_body), Color::BLACK, TextAlign::TOP_CENTER, "CLAUDE ASKS");

          // Question text
          std::string clean_msg = "";
          for (char c : msg) {
            if (c == '\n' || (c >= 32 && c <= 126)) clean_msg += c;
          }

          std::vector<std::string> lines;
          size_t start = 0, end;
          while ((end = clean_msg.find('\n', start)) != std::string::npos) {
              lines.push_back(clean_msg.substr(start, end - start));
              start = end + 1;
          }
          lines.push_back(clean_msg.substr(start));

          int y = 35;
          for (const auto& line : lines) {
              if (line.empty()) { y += 12; continue; }
              it.print(120, y, id(font_body), Color::WHITE, TextAlign::CENTER, line.c_str());
              y += 20;
              if (y > 100) break;
          }

          // Flashing button hint
          if (pulse_frame < 5) {
            it.filled_rectangle(60, 115, 120, 20, LIME);
            it.print(120, 118, id(font_body), Color::BLACK, TextAlign::CENTER, "Press A = YES");
          } else {
            it.rectangle(60, 115, 120, 20, LIME);
            it.print(120, 118, id(font_body), LIME, TextAlign::CENTER, "Press A = YES");
          }
          return;
      }

      // === AGENT MODE - Claude Code is working ===
      if (mode == "AGENT") {
          int code_frame = (millis() / 80) % 40;  // Fast animation

          // Matrix-style falling code effect
          for (int col = 0; col < 12; col++) {
            int offset = (col * 7 + code_frame * 3) % 40;
            for (int row = 0; row < 6; row++) {
              int y = (row * 22 + offset) % 135;
              int brightness = 255 - (row * 40);
              if (brightness < 50) brightness = 50;
              Color code_color = Color(0, brightness, brightness / 2);
              // Random "characters" (just rectangles of varying sizes)
              int char_w = 3 + ((col + row + code_frame) % 4);
              it.filled_rectangle(20 + col * 18, y, char_w, 8, code_color);
            }
          }

          // Agent status overlay
          it.filled_rectangle(40, 45, 160, 50, Color(0, 0, 0));
          it.rectangle(40, 45, 160, 50, CYAN);

          // Show what's happening
          it.print(120, 55, id(font_body), CYAN, TextAlign::CENTER, "AGENT ACTIVE");

          // Tool name from display text
          if (!msg.empty() && msg != "CLAWDBOT READY") {
            std::string tool_display = msg.substr(0, 18);
            it.print(120, 78, id(font_small), LIME, TextAlign::CENTER, tool_display.c_str());
          } else {
            it.print(120, 78, id(font_small), DIM, TextAlign::CENTER, "Working...");
          }

          // Spinning indicator in corner
          int spin = code_frame % 8;
          const char* spinner[] = {"|", "/", "-", "\\", "|", "/", "-", "\\"};
          it.print(215, 5, id(font_body), CYAN, TextAlign::TOP_RIGHT, spinner[spin]);

          return;
      }

      // === IDLE / HOME SCREEN - Clean with accent ===
      if (mode == "IDLE" || msg == "CLAWDBOT READY" || msg.empty()) {
          // Subtle top accent line
          it.line(40, 8, 200, 8, TEAL);

          // Large clock - white for readability
          it.strftime(120, 45, id(font_large), Color::WHITE, TextAlign::CENTER, "%H:%M", id(sntp_time).now());

          // Accent divider
          it.line(60, 78, 180, 78, CYAN);

          // Weather in teal if available
          std::string weather = id(weather_display).state;
          if (!weather.empty()) {
            it.print(120, 92, id(font_body), TEAL, TextAlign::CENTER, weather.c_str());
          }

          // Bottom status bar
          if (id(battery_level).has_state()) {
            float batt = id(battery_level).state;
            Color batt_color = (batt > 50) ? LIME : ((batt > 20) ? AMBER : RED);
            it.printf(120, 120, id(font_small), batt_color, TextAlign::CENTER, "%.0f%%", batt);

            // Battery bar
            int bar_width = (batt / 100.0) * 40;
            it.rectangle(100, 130, 40, 4, DIM);
            it.filled_rectangle(100, 130, bar_width, 4, batt_color);
          }

          // Connection pulse - cyan
          if (id(pulse_state)) {
            it.filled_circle(120, 4, 2, CYAN);
          }

          // Lobster icon hint (small)
          it.print(10, 120, id(font_small), CORAL, TextAlign::TOP_LEFT, ">");
          return;
      }

      // === ALERT MODE - Red urgency ===
      if (mode == "ALERT") {
          // Flashing red header
          Color header_color = id(pulse_state) ? RED : ORANGE;
          it.filled_rectangle(0, 0, 240, 28, header_color);
          it.print(120, 6, id(font_body), Color::WHITE, TextAlign::TOP_CENTER, "! ALERT !");

          // Message in white on dark
          std::string clean_msg = "";
          for (char c : msg) {
            if (c == '\n' || (c >= 32 && c <= 126)) clean_msg += c;
          }

          std::vector<std::string> lines;
          size_t start = 0, end;
          while ((end = clean_msg.find('\n', start)) != std::string::npos) {
              lines.push_back(clean_msg.substr(start, end - start));
              start = end + 1;
          }
          lines.push_back(clean_msg.substr(start));

          int y = 45;
          for (const auto& line : lines) {
              if (line.empty()) { y += 12; continue; }
              it.print(120, y, id(font_body), Color::WHITE, TextAlign::CENTER, line.c_str());
              y += 22;
          }
          return;
      }

      // === RESPONSE MODE - Clean with coral accent ===
      // Header bar with time and battery
      it.filled_rectangle(0, 0, 240, 22, Color(20, 20, 30));
      it.line(0, 22, 240, 22, CORAL);
      it.strftime(8, 4, id(font_small), DIM, TextAlign::TOP_LEFT, "%H:%M", id(sntp_time).now());
      it.print(120, 4, id(font_small), CORAL, TextAlign::TOP_CENTER, "CLAWDBOT");

      if (id(battery_level).has_state()) {
        it.printf(232, 4, id(font_small), DIM, TextAlign::TOP_RIGHT, "%.0f%%", id(battery_level).state);
      }

      // Sanitize and display message
      std::string clean_msg = "";
      for (char c : msg) {
        if (c == '\n' || (c >= 32 && c <= 126)) clean_msg += c;
      }

      std::vector<std::string> lines;
      size_t start = 0, end;
      while ((end = clean_msg.find('\n', start)) != std::string::npos) {
          lines.push_back(clean_msg.substr(start, end - start));
          start = end + 1;
      }
      lines.push_back(clean_msg.substr(start));

      // Center content vertically
      int y = (lines.size() > 4) ? 28 : ((lines.size() > 2) ? 40 : 55);
      for (const auto& line : lines) {
          if (line.empty()) { y += 12; continue; }
          it.print(120, y, id(font_body), Color::WHITE, TextAlign::CENTER, line.c_str());
          y += 22;
      }

font:
  - file: "gfonts://Roboto Mono"
    id: font_large
    size: 38
  - file: "gfonts://Roboto Mono"
    id: font_body
    size: 16
  - file: "gfonts://Roboto Mono"
    id: font_small
    size: 10
