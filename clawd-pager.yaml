esphome:
  name: clawd-pager
  friendly_name: "Clawd Pager"
  includes:
    - audio_streamer.h
  on_boot:
    priority: -10
    then:
      # Fun Mario-style startup jingle!
      - rtttl.play: "Mario:d=4,o=5,b=200:e6,8e6,8e6,8c6,e6,g6,g"
      - text_sensor.template.publish:
          id: pager_display
          state: "LOBSTER READY!"
      - text_sensor.template.publish:
          id: display_mode
          state: "IDLE"
      - text_sensor.template.publish:
          id: weather_display
          state: ""
      - lambda: |-
          // Initialize audio streamer with bridge IP and port
          audio_streamer().begin("192.168.50.50", 12345);

esp32:
  board: m5stick-c
  framework:
    type: arduino

external_components:
  # Using makerwolf fork for charging detection support
  - source: github://makerwolf/esphome-axp192
    components: [axp192]

i2c:
  sda: 21
  scl: 22

# I2S Audio for PDM microphone (SPM1423)
# M5StickC Plus 1.1: CLK=GPIO0, Data=GPIO34
# NOTE: Buzzer must be OFF during recording - they share resources!
i2s_audio:
  - id: mic_i2s_bus
    i2s_lrclk_pin:
      number: GPIO0
      ignore_strapping_warning: true

microphone:
  - platform: i2s_audio
    id: mic_i2s
    i2s_audio_id: mic_i2s_bus
    i2s_din_pin: GPIO34
    adc_type: external
    pdm: true
    channel: left
    on_data:
      - lambda: |-
          // Stream audio via UDP to bridge when recording
          if (id(is_recording) && x.size() > 0) {
            audio_streamer().send_audio(x.data(), x.size());
          }

logger:
  level: DEBUG

api:
  services:
    # Main display update service - called by bridge
    - service: set_display
      variables:
        my_text: string
        my_mode: string
      then:
        - text_sensor.template.publish:
            id: pager_display
            state: !lambda "return my_text;"
        - text_sensor.template.publish:
            id: display_mode
            state: !lambda "return my_mode;"
        - if:
            condition:
              lambda: 'return my_mode != "SILENT";'
            then:
              - rtttl.play: "Blip:d=32,o=6,b=150:c6"
        - script.execute: activity_watcher
    
    # Weather widget update
    - service: update_weather
      variables:
        my_weather: string
      then:
        - text_sensor.template.publish:
            id: weather_display
            state: !lambda "return my_weather;"
    
    # Alert with distinct tone
    - service: alert
      variables:
        my_text: string
      then:
        - rtttl.play: "Alert:d=16,o=6,b=180:c,e,g,c7"
        - text_sensor.template.publish:
            id: pager_display
            state: !lambda "return my_text;"
        - text_sensor.template.publish:
            id: display_mode
            state: "ALERT"
        - script.execute: activity_watcher
        - lambda: |-
            if (id(dev_mode)) {
              id(event_seq)++;
              ESP_LOGI("EVENT", "[%d] ALERT | text=%s", id(event_seq), my_text.c_str());
            }

    # Toggle development mode (verbose logging)
    - service: set_dev_mode
      variables:
        enabled: bool
      then:
        - globals.set:
            id: dev_mode
            value: !lambda "return enabled;"
        - lambda: |-
            ESP_LOGI("EVENT", "DEV_MODE %s", enabled ? "ENABLED" : "DISABLED");

    # Get current device state (for dashboard polling)
    - service: get_state
      then:
        - lambda: |-
            ESP_LOGI("STATE", "mode=%s battery=%.0f dev_mode=%s",
                     id(display_mode).state.c_str(),
                     id(battery_level).has_state() ? id(battery_level).state : 0.0,
                     id(dev_mode) ? "true" : "false");

ota:
  - platform: esphome

wifi:
  ssid: "FlyingChanges"
  password: "flyingchanges"
  fast_connect: true
  power_save_mode: none

time:
  - platform: sntp
    id: sntp_time
    timezone: "EST5EDT,M3.2.0,M11.1.0"

output:
  - platform: ledc
    id: buzzer_pwm
    pin: GPIO2

rtttl:
  output: buzzer_pwm
  id: buzzer

sensor:
  - platform: axp192
    model: M5STICKC
    address: 0x34
    id: my_axp
    battery_level:
      name: "Battery"
      id: battery_level

binary_sensor:
  # Charging detection via template - polls AXP192 charging status
  - platform: template
    name: "Charging"
    id: is_charging
    lambda: |-
      // Check if battery is charging by comparing voltage/current
      // AXP192 reports charging when VBUS is present and battery < 100%
      return id(battery_level).state < 99.0;
    on_press:
      then:
        - lambda: |-
            if (id(dev_mode)) {
              id(event_seq)++;
              ESP_LOGI("EVENT", "[%d] CHARGING_START", id(event_seq));
            }
            // Full brightness when charging - we have power!
            id(my_axp).set_brightness(1.0);
        - if:
            condition:
              lambda: 'return id(display_mode).state == "IDLE";'
            then:
              - text_sensor.template.publish:
                  id: display_mode
                  state: "DOCKED"
    on_release:
      then:
        - lambda: |-
            if (id(dev_mode)) {
              id(event_seq)++;
              ESP_LOGI("EVENT", "[%d] CHARGING_STOP", id(event_seq));
            }
        - if:
            condition:
              lambda: 'return id(display_mode).state == "DOCKED";'
            then:
              - text_sensor.template.publish:
                  id: display_mode
                  state: "IDLE"

  # Button A - YES / CONFIRM / VOICE (hold)
  # New ergonomic layout: A is the main action button
  - platform: gpio
    pin:
      number: GPIO37
      inverted: true
    name: "Button A"
    id: button_a
    on_multi_click:
      # Short tap = Context-aware action
      - timing:
          - ON for at most 400ms
          - OFF for at least 50ms
        then:
          - lambda: |-
              std::string mode = id(display_mode).state;
              if (id(dev_mode)) {
                id(event_seq)++;
                ESP_LOGI("EVENT", "[%d] BUTTON_A_TAP | mode=%s", id(event_seq), mode.c_str());
              }
          - script.execute: activity_watcher
          - if:
              condition:
                lambda: 'return id(display_mode).state == "QUESTION";'
              then:
                # YES response - Zelda "item get" style!
                - rtttl.play: "Yes:d=16,o=5,b=200:g,c6,e6,g6,8e6,8g6"
                - text_sensor.template.publish:
                    id: pager_display
                    state: "YES!"
                - text_sensor.template.publish:
                    id: display_mode
                    state: "RESPONSE"
          - if:
              condition:
                lambda: 'return id(display_mode).state == "CONFIRM";'
              then:
                # SEND - whoosh sound!
                - rtttl.play: "Send:d=32,o=5,b=300:c,d,e,f,g,a,b,c6,d6,e6"
                - text_sensor.template.publish:
                    id: pager_display
                    state: "SENDING..."
                - text_sensor.template.publish:
                    id: display_mode
                    state: "PROCESSING"
          - if:
              condition:
                lambda: 'return id(display_mode).state == "IDLE" || id(display_mode).state == "DOCKED";'
              then:
                # Get STATUS from Clawdbot
                - rtttl.play: "Blip:d=32,o=6,b=150:c6"
                - text_sensor.template.publish:
                    id: pager_display
                    state: "Getting status..."
                - text_sensor.template.publish:
                    id: display_mode
                    state: "PROCESSING"
      # Long hold (400ms+) = VOICE recording
      - timing:
          - ON for at least 400ms
        then:
          # Fun "listening" chirp!
          - rtttl.play: "Listen:d=16,o=6,b=200:c,g,c7"
          - delay: 100ms
          # CRITICAL: Stop buzzer before recording - they share resources!
          - output.turn_off: buzzer_pwm
          - globals.set:
              id: btn_a_pressed
              value: 'true'
          - globals.set:
              id: is_recording
              value: 'true'
          - text_sensor.template.publish:
              id: display_mode
              state: "LISTENING"
          - text_sensor.template.publish:
              id: pager_display
              state: "LISTENING..."
          - script.execute: activity_watcher
          - lambda: |-
              audio_streamer().start_recording();
              if (id(dev_mode)) {
                id(event_seq)++;
                ESP_LOGI("EVENT", "[%d] BUTTON_A_HOLD | mode=LISTENING", id(event_seq));
              }
          - microphone.capture: mic_i2s
    on_release:
      then:
        - if:
            condition:
              lambda: 'return id(btn_a_pressed);'
            then:
              - microphone.stop_capture: mic_i2s
              - lambda: |-
                  id(is_recording) = false;
                  audio_streamer().stop_recording();
                  ESP_LOGI("AUDIO", "Sent %d bytes", audio_streamer().bytes_sent());
              # Satisfying "got it!" chirps
              - rtttl.play: "Done:d=16,o=6,b=200:c,e,c"
              - globals.set:
                  id: btn_a_pressed
                  value: 'false'
              - text_sensor.template.publish:
                  id: display_mode
                  state: "PROCESSING"
              - text_sensor.template.publish:
                  id: pager_display
                  state: "PROCESSING..."
              - lambda: |-
                  if (id(dev_mode)) {
                    id(event_seq)++;
                    ESP_LOGI("EVENT", "[%d] BUTTON_A_RELEASE | mode=PROCESSING | bytes=%d", id(event_seq), audio_streamer().bytes_sent());
                  }

  # Button B - NO / BACK / CANCEL
  - platform: gpio
    pin:
      number: GPIO39
      inverted: true
    name: "Button B"
    id: button_b
    on_click:
      min_length: 50ms
      max_length: 500ms
      then:
        - lambda: |-
            std::string mode = id(display_mode).state;
            if (id(dev_mode)) {
              id(event_seq)++;
              ESP_LOGI("EVENT", "[%d] BUTTON_B_TAP | mode=%s", id(event_seq), mode.c_str());
            }
        - script.execute: activity_watcher
        - if:
            condition:
              lambda: 'return id(display_mode).state == "QUESTION";'
            then:
              # NO response - sad trombone wah wah!
              - rtttl.play: "No:d=8,o=5,b=120:b,4a#,4a,2g#"
              - text_sensor.template.publish:
                  id: pager_display
                  state: "NO"
              - text_sensor.template.publish:
                  id: display_mode
                  state: "RESPONSE"
        - if:
            condition:
              lambda: 'return id(display_mode).state == "CONFIRM";'
            then:
              # CANCEL - don't send
              - rtttl.play: "Cancel:d=16,o=5,b=200:c,c"
              - text_sensor.template.publish:
                  id: pager_display
                  state: "Cancelled"
              - delay: 500ms
              - text_sensor.template.publish:
                  id: display_mode
                  state: "IDLE"
              - text_sensor.template.publish:
                  id: pager_display
                  state: "CLAWDBOT READY"
        - if:
            condition:
              lambda: |-
                std::string m = id(display_mode).state;
                return m != "QUESTION" && m != "CONFIRM" && m != "IDLE";
            then:
              # BACK to home
              - rtttl.play: "Back:d=32,o=5,b=150:c"
              - text_sensor.template.publish:
                  id: display_mode
                  state: "IDLE"
              - text_sensor.template.publish:
                  id: pager_display
                  state: "CLAWDBOT READY"

  # Power Button - Toggle brightness
  - platform: gpio
    pin:
      number: GPIO35
      inverted: true
    name: "Power Button"
    on_click:
      min_length: 50ms
      max_length: 500ms
      then:
        - lambda: |-
            id(screen_bright) = !id(screen_bright);
            id(my_axp).set_brightness(id(screen_bright) ? 1.0 : 0.2);

# Text sensors - exposed to bridge
text_sensor:
  - platform: template
    id: pager_display
    name: "Pager Display"
  - platform: template
    id: weather_display
    name: "Weather Display"
  - platform: template
    id: display_mode
    name: "Display Mode"

globals:
  - id: pulse_state
    type: bool
    initial_value: 'false'
  - id: btn_a_pressed
    type: bool
    initial_value: 'false'
  - id: btn_b_pressed
    type: bool
    initial_value: 'false'
  - id: screen_bright
    type: bool
    initial_value: 'true'
  # Development mode - enables verbose event logging
  - id: dev_mode
    type: bool
    initial_value: 'true'
  # Event sequence counter for ordering
  - id: event_seq
    type: int
    initial_value: '0'
  # Audio recording state
  - id: is_recording
    type: bool
    initial_value: 'false'

script:
  - id: activity_watcher
    mode: restart
    then:
      - lambda: |-
          id(my_axp).set_brightness(1.0);
      - delay: 30s
      - lambda: |-
          // Don't dim if charging/docked - we have power!
          if (id(display_mode).state != "DOCKED") {
            id(my_axp).set_brightness(0.4);
          }
      - delay: 30s
      - lambda: |-
          // Don't dim if charging/docked
          if (id(display_mode).state != "DOCKED") {
            id(my_axp).set_brightness(0.1);
          }

spi:
  clk_pin: GPIO13
  mosi_pin: GPIO15

display:
  - platform: st7789v
    model: TTGO_TDisplay_135x240
    cs_pin: GPIO5
    dc_pin: GPIO23
    reset_pin: GPIO18
    rotation: 270
    update_interval: 0.5s
    lambda: |-
      // === COLOR PALETTE ===
      Color CYAN = Color(0, 255, 255);
      Color TEAL = Color(0, 200, 200);
      Color CORAL = Color(255, 127, 80);
      Color AMBER = Color(255, 191, 0);
      Color LIME = Color(50, 205, 50);
      Color PINK = Color(255, 105, 180);
      Color PURPLE = Color(147, 112, 219);
      Color RED = Color(255, 60, 60);
      Color ORANGE = Color(255, 140, 0);
      Color DIM = Color(100, 100, 100);

      it.fill(Color::BLACK);
      id(pulse_state) = !id(pulse_state);
      int frame = (millis() / 100) % 20;  // Animation frame

      std::string mode = id(display_mode).state;
      std::string msg = id(pager_display).state;

      // === LISTENING MODE - Rainbow waveform (Pixar-style!) ===
      if (mode == "LISTENING") {
          // Rainbow colors for bars
          Color rainbow[] = {
            Color(255, 50, 50),    // Red
            Color(255, 150, 0),    // Orange
            Color(255, 220, 0),    // Yellow
            Color(100, 255, 50),   // Lime
            Color(0, 220, 180),    // Teal
            Color(50, 150, 255),   // Blue
            Color(150, 100, 255),  // Purple
            Color(255, 100, 200),  // Pink
            Color(255, 150, 0),    // Orange
            Color(255, 220, 0),    // Yellow
            Color(100, 255, 50),   // Lime
            Color(0, 220, 180)     // Teal
          };

          // Bouncy rainbow waveform
          for (int i = 0; i < 12; i++) {
            int phase = (frame + i * 3) % 20;
            int h = 10 + abs(10 - phase) * 3;
            it.filled_rectangle(25 + i * 17, 68 - h, 12, h * 2, rainbow[i]);
          }

          // Cute bouncing mic icon (circle with lines)
          int bounce = abs((frame % 10) - 5);
          it.filled_circle(120, 115 + bounce, 8, Color::WHITE);
          it.filled_rectangle(117, 123 + bounce, 6, 8, Color::WHITE);

          return;
      }

      // === CONFIRM MODE - Show transcription, confirm before sending ===
      if (mode == "CONFIRM") {
          // Header with teal gradient effect
          it.filled_rectangle(0, 0, 240, 22, TEAL);
          it.print(120, 4, id(font_body), Color::BLACK, TextAlign::TOP_CENTER, "CONFIRM?");

          // Transcription text (the message contains what was heard)
          std::string clean_msg = "";
          for (char c : msg) {
            if (c == '\n' || (c >= 32 && c <= 126)) clean_msg += c;
          }

          // Word wrap the transcription
          std::vector<std::string> lines;
          std::string current_line = "";
          for (size_t i = 0; i < clean_msg.length(); i++) {
            current_line += clean_msg[i];
            if (current_line.length() > 22 || clean_msg[i] == '\n') {
              lines.push_back(current_line);
              current_line = "";
            }
          }
          if (!current_line.empty()) lines.push_back(current_line);

          // Display transcription in white
          int y = 30;
          for (size_t i = 0; i < lines.size() && i < 4; i++) {
            it.print(120, y, id(font_body), Color::WHITE, TextAlign::CENTER, lines[i].c_str());
            y += 18;
          }

          // Button hints with pulsing animation
          int pulse_frame = (millis() / 400) % 6;

          // A = SEND (green, left side)
          Color send_color = (pulse_frame < 3) ? LIME : Color(30, 150, 30);
          it.filled_rectangle(15, 108, 100, 24, send_color);
          it.print(65, 113, id(font_body), Color::BLACK, TextAlign::CENTER, "A = SEND");

          // B = CANCEL (coral, right side)
          Color cancel_color = (pulse_frame >= 3) ? CORAL : Color(180, 80, 50);
          it.filled_rectangle(125, 108, 100, 24, cancel_color);
          it.print(175, 113, id(font_body), Color::BLACK, TextAlign::CENTER, "B = CANCEL");

          return;
      }

      // === PROCESSING MODE - Colorful bouncing dots ===
      if (mode == "PROCESSING") {
          // Rainbow bouncing dots instead of boring spinner
          Color dot_colors[] = {
            Color(255, 50, 50),    // Red
            Color(255, 150, 0),    // Orange
            Color(255, 220, 0),    // Yellow
            Color(100, 255, 50),   // Lime
            Color(0, 200, 220),    // Cyan
            Color(100, 100, 255),  // Blue
            Color(200, 100, 255),  // Purple
            Color(255, 100, 200)   // Pink
          };

          // Bouncing dots in a wave with shadows and glow
          for (int i = 0; i < 8; i++) {
            int bounce = abs(((frame * 2 + i * 5) % 30) - 15);
            int x = 50 + i * 22;
            int y = 55 + bounce;
            int size = 6 + (bounce / 5);

            // Shadow below (gets bigger when higher)
            int shadow_y = 70;
            int shadow_w = (size + 2) * 2;
            it.filled_rectangle(x - shadow_w / 2, shadow_y, shadow_w, 2, Color(0, 0, 0, 100));

            // Glow/halo effect
            Color glow_color = dot_colors[i];
            glow_color.r /= 3; glow_color.g /= 3; glow_color.b /= 3;
            it.filled_circle(x, y, size + 2, glow_color);

            // Main dot
            it.filled_circle(x, y, size, dot_colors[i]);

            // Highlight
            it.filled_circle(x - 1, y - 1, 2, Color(255, 255, 255));
          }

          it.print(120, 100, id(font_body), AMBER, TextAlign::CENTER, "PROCESSING");
          it.print(120, 120, id(font_small), DIM, TextAlign::CENTER, "Thinking...");
          return;
      }

      // === AWAITING MODE - Purple pulse ===
      if (mode == "AWAITING") {
          it.print(120, 35, id(font_body), PURPLE, TextAlign::CENTER, "AWAITING");
          it.print(120, 55, id(font_body), PURPLE, TextAlign::CENTER, "RESPONSE");

          // Pulsing concentric circles
          int pulse_size = 5 + (frame % 10) * 2;
          it.circle(120, 95, pulse_size, PURPLE);
          it.circle(120, 95, pulse_size + 8, PINK);
          if (id(pulse_state)) {
            it.filled_circle(120, 95, 4, PURPLE);
          }
          return;
      }

      // === DOCKED MODE - Ambient display when charging ===
      if (mode == "DOCKED") {
          // Dark ambient background with floating particles
          int slow_frame = (millis() / 200) % 100;

          // Orbiting particles around center
          for (int i = 0; i < 6; i++) {
            float angle = (i * 60 + slow_frame * 3.6) * 3.14159 / 180;
            int radius = 35 + (i % 2) * 15;
            int x = 120 + cos(angle) * radius;
            int y = 68 + sin(angle) * (radius / 2);  // Elliptical orbit
            Color particle_color = (i % 3 == 0) ? CYAN : ((i % 3 == 1) ? PURPLE : PINK);
            int size = 2 + (slow_frame + i * 16) % 3;
            it.filled_circle(x, y, size, particle_color);
          }

          // Gentle clock in center
          it.strftime(120, 50, id(font_large), CYAN, TextAlign::CENTER, "%H:%M", id(sntp_time).now());

          // Subtle "DOCKED" indicator
          it.print(120, 95, id(font_small), DIM, TextAlign::CENTER, "DOCKED");

          // Charging indicator - animated lightning bolt effect
          int bolt_y = 115 + (slow_frame % 10 < 5 ? 0 : 2);
          it.print(110, bolt_y, id(font_small), LIME, TextAlign::CENTER, "++");

          // Battery with fill animation
          if (id(battery_level).has_state()) {
            float batt = id(battery_level).state;
            int fill = (int)(batt / 100.0 * 30) + (slow_frame % 5);
            if (fill > 30) fill = 30;
            it.rectangle(105, 125, 30, 8, LIME);
            it.filled_rectangle(105, 125, fill, 8, LIME);
            it.printf(140, 125, id(font_small), LIME, "%.0f%%", batt);
          }
          return;
      }

      // === QUESTION MODE - Claude Code is asking something ===
      if (mode == "QUESTION") {
          int pulse_frame = (millis() / 300) % 10;

          // Attention-getting header
          Color question_color = id(pulse_state) ? AMBER : ORANGE;
          it.filled_rectangle(0, 0, 240, 25, question_color);
          it.print(120, 5, id(font_body), Color::BLACK, TextAlign::TOP_CENTER, "CLAUDE ASKS");

          // Question text with word wrapping
          std::string clean_msg = "";
          for (char c : msg) {
            if (c == '\n' || (c >= 32 && c <= 126)) clean_msg += c;
          }

          // Word wrap at 24 chars (safe for 240px screen with 16px font)
          std::vector<std::string> lines;
          const int MAX_CHARS = 24;

          // Split by newlines first, then wrap each paragraph
          size_t para_start = 0, para_end;
          while ((para_end = clean_msg.find('\n', para_start)) != std::string::npos) {
              std::string para = clean_msg.substr(para_start, para_end - para_start);
              if (!para.empty()) {
                  // Wrap this paragraph
                  std::string current_line = "";
                  size_t word_start = 0;
                  while (word_start < para.length()) {
                      size_t word_end = para.find(' ', word_start);
                      if (word_end == std::string::npos) word_end = para.length();
                      std::string word = para.substr(word_start, word_end - word_start);

                      if (current_line.empty()) {
                          current_line = word;
                      } else if (current_line.length() + 1 + word.length() <= MAX_CHARS) {
                          current_line += " " + word;
                      } else {
                          lines.push_back(current_line);
                          current_line = word;
                      }
                      word_start = (word_end == para.length()) ? word_end : word_end + 1;
                  }
                  if (!current_line.empty()) lines.push_back(current_line);
              }
              para_start = para_end + 1;
          }
          // Handle last paragraph
          std::string para = clean_msg.substr(para_start);
          if (!para.empty()) {
              std::string current_line = "";
              size_t word_start = 0;
              while (word_start < para.length()) {
                  size_t word_end = para.find(' ', word_start);
                  if (word_end == std::string::npos) word_end = para.length();
                  std::string word = para.substr(word_start, word_end - word_start);

                  if (current_line.empty()) {
                      current_line = word;
                  } else if (current_line.length() + 1 + word.length() <= MAX_CHARS) {
                      current_line += " " + word;
                  } else {
                      lines.push_back(current_line);
                      current_line = word;
                  }
                  word_start = (word_end == para.length()) ? word_end : word_end + 1;
              }
              if (!current_line.empty()) lines.push_back(current_line);
          }

          // Auto-scroll if more than 3 lines (fits in y=35 to y=95)
          const int MAX_VISIBLE_LINES = 3;
          int scroll_offset = 0;
          if (lines.size() > MAX_VISIBLE_LINES) {
              // Scroll every 2.5 seconds
              int scroll_index = (millis() / 2500) % lines.size();
              scroll_offset = scroll_index;
          }

          int y = 35;
          int displayed = 0;
          for (size_t i = scroll_offset; i < lines.size() && displayed < MAX_VISIBLE_LINES; i++) {
              if (lines[i].empty()) { y += 12; continue; }
              it.print(120, y, id(font_body), Color::WHITE, TextAlign::CENTER, lines[i].c_str());
              y += 20;
              displayed++;
          }

          // Flashing button hint
          if (pulse_frame < 5) {
            it.filled_rectangle(60, 115, 120, 20, LIME);
            it.print(120, 118, id(font_body), Color::BLACK, TextAlign::CENTER, "Press A = YES");
          } else {
            it.rectangle(60, 115, 120, 20, LIME);
            it.print(120, 118, id(font_body), LIME, TextAlign::CENTER, "Press A = YES");
          }
          return;
      }

      // === AGENT_EDIT MODE - File editing with diff stats ===
      if (mode == "AGENT_EDIT") {
          int edit_frame = (millis() / 100) % 20;

          // Green accent for additions, parse message for +/- info
          Color accent = LIME;
          if (msg.find("-") != std::string::npos && msg.find("+") == std::string::npos) {
              accent = RED;  // Deletions
          } else if (msg.find("~") != std::string::npos) {
              accent = AMBER;  // Modifications
          }

          // Animated code brackets
          int bracket_bounce = abs(edit_frame - 10);
          it.print(20 + bracket_bounce, 30, id(font_large), accent, TextAlign::CENTER, "{");
          it.print(220 - bracket_bounce, 30, id(font_large), accent, TextAlign::CENTER, "}");

          // File info centered
          std::string line1 = msg.substr(0, msg.find('\n'));
          std::string line2 = "";
          if (msg.find('\n') != std::string::npos) {
              line2 = msg.substr(msg.find('\n') + 1);
          }

          it.print(120, 50, id(font_body), Color::WHITE, TextAlign::CENTER, line1.c_str());
          it.print(120, 75, id(font_body), accent, TextAlign::CENTER, line2.c_str());

          // Animated progress bar
          int bar_width = (edit_frame * 12) % 200;
          it.filled_rectangle(20, 105, bar_width, 8, accent);
          it.rectangle(20, 105, 200, 8, DIM);

          return;
      }

      // === AGENT_NEW MODE - Creating new file ===
      if (mode == "AGENT_NEW") {
          int new_frame = (millis() / 150) % 20;

          // Sparkle effect for new file
          Color sparkles[] = {CYAN, Color::WHITE, PINK, CYAN};
          for (int i = 0; i < 8; i++) {
              int x = 30 + ((i * 47 + new_frame * 13) % 180);
              int y = 10 + ((i * 23 + new_frame * 7) % 25);
              int size = 1 + (new_frame + i) % 3;
              it.filled_circle(x, y, size, sparkles[i % 4]);
          }

          // File icon (simple doc shape)
          it.filled_rectangle(95, 45, 50, 60, Color(30, 30, 40));
          it.filled_rectangle(95, 45, 50, 15, CYAN);
          it.filled_rectangle(130, 45, 15, 15, Color(30, 30, 40));  // Folded corner

          // Plus sign
          it.filled_rectangle(115, 70, 20, 4, LIME);
          it.filled_rectangle(123, 62, 4, 20, LIME);

          // File name below
          std::string line1 = msg.substr(0, msg.find('\n'));
          it.print(120, 115, id(font_body), CYAN, TextAlign::CENTER, line1.c_str());

          return;
      }

      // === AGENT_BASH MODE - Terminal command ===
      if (mode == "AGENT_BASH") {
          int bash_frame = (millis() / 100) % 30;

          // Terminal background
          it.filled_rectangle(10, 10, 220, 115, Color(10, 10, 15));
          it.rectangle(10, 10, 220, 115, ORANGE);

          // Terminal title bar
          it.filled_rectangle(10, 10, 220, 18, Color(40, 30, 20));
          it.print(120, 12, id(font_small), ORANGE, TextAlign::TOP_CENTER, "TERMINAL");

          // Prompt with blinking cursor
          it.print(20, 35, id(font_body), LIME, TextAlign::TOP_LEFT, "$");

          // Command text (from msg)
          std::string cmd = msg;
          if (cmd.length() > 28) cmd = cmd.substr(0, 28) + "...";
          it.print(35, 35, id(font_body), Color::WHITE, TextAlign::TOP_LEFT, cmd.c_str());

          // Blinking cursor
          if (bash_frame < 15) {
              int cursor_x = 35 + cmd.length() * 8;
              if (cursor_x > 200) cursor_x = 200;
              it.filled_rectangle(cursor_x, 35, 8, 16, ORANGE);
          }

          // Running indicator
          std::string dots = "";
          for (int i = 0; i < (bash_frame / 5) % 4; i++) dots += ".";
          it.print(20, 65, id(font_small), DIM, TextAlign::TOP_LEFT, ("Running" + dots).c_str());

          return;
      }

      // === AGENT_SEARCH MODE - Grep/Glob search ===
      if (mode == "AGENT_SEARCH") {
          int search_frame = (millis() / 80) % 40;

          // Scanning lines animation
          for (int i = 0; i < 10; i++) {
              int y = ((i * 13 + search_frame * 4) % 135);
              int alpha = 255 - abs(67 - y) * 3;
              if (alpha < 30) alpha = 30;
              Color line_color = Color(147 * alpha / 255, 112 * alpha / 255, 219 * alpha / 255);
              it.line(20, y, 220, y, line_color);
          }

          // Magnifying glass icon
          int glass_bounce = abs((search_frame % 20) - 10) / 3;
          it.circle(50, 55 + glass_bounce, 15, PURPLE);
          it.circle(50, 55 + glass_bounce, 14, PURPLE);
          it.line(60, 65 + glass_bounce, 75, 80 + glass_bounce, PURPLE);
          it.line(61, 66 + glass_bounce, 76, 81 + glass_bounce, PURPLE);

          // Search text
          std::string line1 = msg.substr(0, msg.find('\n'));
          if (line1.length() > 20) line1 = line1.substr(0, 20) + "...";
          it.print(140, 50, id(font_body), PURPLE, TextAlign::CENTER, line1.c_str());

          std::string line2 = "";
          if (msg.find('\n') != std::string::npos) {
              line2 = msg.substr(msg.find('\n') + 1);
          }
          it.print(140, 75, id(font_small), DIM, TextAlign::CENTER, line2.c_str());

          return;
      }

      // === AGENT_WEB MODE - Web fetch/search ===
      if (mode == "AGENT_WEB") {
          int web_frame = (millis() / 60) % 60;

          // Globe animation (spinning dots)
          for (int i = 0; i < 12; i++) {
              float angle = (i * 30 + web_frame * 6) * 3.14159 / 180;
              int x = 50 + cos(angle) * 25;
              int y = 55 + sin(angle) * 15;
              Color dot_color = (i % 2 == 0) ? CYAN : TEAL;
              it.filled_circle(x, y, 3, dot_color);
          }
          it.circle(50, 55, 25, CYAN);
          it.line(25, 55, 75, 55, TEAL);
          it.line(50, 30, 50, 80, TEAL);

          // URL/query text
          std::string line1 = msg.substr(0, msg.find('\n'));
          it.print(150, 45, id(font_body), CYAN, TextAlign::CENTER, line1.c_str());

          std::string line2 = "";
          if (msg.find('\n') != std::string::npos) {
              line2 = msg.substr(msg.find('\n') + 1);
              if (line2.length() > 20) line2 = line2.substr(0, 20) + "...";
          }
          it.print(150, 70, id(font_small), DIM, TextAlign::CENTER, line2.c_str());

          // Loading bar
          int bar_pos = (web_frame * 4) % 200;
          it.filled_rectangle(20 + bar_pos, 105, 30, 6, CYAN);

          return;
      }

      // === AGENT_SUB MODE - Sub-agent working ===
      if (mode == "AGENT_SUB") {
          int sub_frame = (millis() / 100) % 30;

          // Multiple bouncing agents (dots)
          Color agent_colors[] = {PINK, PURPLE, CYAN, LIME};
          for (int i = 0; i < 4; i++) {
              int bounce = abs(((sub_frame + i * 7) % 20) - 10);
              int x = 40 + i * 50;
              it.filled_circle(x, 50 + bounce, 8, agent_colors[i]);
              it.filled_circle(x - 2, 48 + bounce, 2, Color::WHITE);  // Highlight
          }

          // Agent type text
          std::string line1 = msg.substr(0, msg.find('\n'));
          it.print(120, 80, id(font_body), PINK, TextAlign::CENTER, line1.c_str());

          std::string line2 = "";
          if (msg.find('\n') != std::string::npos) {
              line2 = msg.substr(msg.find('\n') + 1);
          }
          it.print(120, 100, id(font_small), DIM, TextAlign::CENTER, line2.c_str());

          return;
      }

      // === AGENT_PLAN MODE - Planning/todos ===
      if (mode == "AGENT_PLAN") {
          int plan_frame = (millis() / 200) % 10;

          // Checklist animation
          it.filled_rectangle(30, 20, 180, 100, Color(20, 20, 15));
          it.rectangle(30, 20, 180, 100, AMBER);

          // Checkboxes appearing
          int visible_boxes = (plan_frame % 4) + 1;
          for (int i = 0; i < visible_boxes && i < 4; i++) {
              int y = 30 + i * 22;
              it.rectangle(45, y, 14, 14, AMBER);
              if (i < visible_boxes - 1) {
                  // Checked
                  it.line(48, y + 7, 52, y + 11, LIME);
                  it.line(52, y + 11, 58, y + 3, LIME);
              }
              // Line placeholder
              int line_w = 80 + (i * 20) % 40;
              it.filled_rectangle(70, y + 4, line_w, 6, Color(60, 60, 50));
          }

          // Planning text
          it.print(120, 125, id(font_small), AMBER, TextAlign::CENTER, msg.c_str());

          return;
      }

      // === AGENT_READ MODE - Reading file ===
      if (mode == "AGENT_READ") {
          int read_frame = (millis() / 50) % 40;

          // Page turning effect - simulated text lines scrolling
          for (int i = 0; i < 8; i++) {
              int y = 25 + i * 12;
              int offset = (read_frame + i * 3) % 20;
              int width = 140 + (offset * 3) - (i * 5);
              if (width > 180) width = 180;
              if (width < 60) width = 60;
              int alpha = 200 - i * 20;
              Color line_color = Color(50 * alpha / 255, 100 * alpha / 255, 200 * alpha / 255);
              it.filled_rectangle(30, y, width, 6, line_color);
          }

          // File name
          std::string filename = msg;
          if (filename.length() > 25) filename = "..." + filename.substr(filename.length() - 22);
          it.print(120, 115, id(font_body), Color(100, 150, 255), TextAlign::CENTER, filename.c_str());

          return;
      }

      // === AGENT MODE - Claude Code is working ===
      if (mode == "AGENT") {
          int code_frame = (millis() / 80) % 40;  // Fast animation

          // Matrix-style falling code effect
          for (int col = 0; col < 12; col++) {
            int offset = (col * 7 + code_frame * 3) % 40;
            for (int row = 0; row < 6; row++) {
              int y = (row * 22 + offset) % 135;
              int brightness = 255 - (row * 40);
              if (brightness < 50) brightness = 50;
              Color code_color = Color(0, brightness, brightness / 2);
              // Random "characters" (just rectangles of varying sizes)
              int char_w = 3 + ((col + row + code_frame) % 4);
              it.filled_rectangle(20 + col * 18, y, char_w, 8, code_color);
            }
          }

          // Agent status overlay
          it.filled_rectangle(40, 45, 160, 50, Color(0, 0, 0));
          it.rectangle(40, 45, 160, 50, CYAN);

          // Show what's happening
          it.print(120, 55, id(font_body), CYAN, TextAlign::CENTER, "AGENT ACTIVE");

          // Tool name from display text
          if (!msg.empty() && msg != "CLAWDBOT READY") {
            std::string tool_display = msg.substr(0, 18);
            it.print(120, 78, id(font_small), LIME, TextAlign::CENTER, tool_display.c_str());
          } else {
            it.print(120, 78, id(font_small), DIM, TextAlign::CENTER, "Working...");
          }

          // Bouncing ball animation (Pixar style!)
          // Ball position bounces with easing
          float ball_time = (millis() % 1200) / 1200.0;  // 1.2s cycle
          float bounce_height;
          if (ball_time < 0.5) {
              // Going up (ease out)
              float t = ball_time * 2.0;
              bounce_height = 1.0 - (1.0 - t) * (1.0 - t);
          } else {
              // Coming down (ease in)
              float t = (ball_time - 0.5) * 2.0;
              bounce_height = 1.0 - t * t;
          }

          int ball_y = 30 + (int)(bounce_height * 15);  // Bounce 15 pixels
          int ball_size = 8 - (int)(bounce_height * 2);  // Squash on impact

          // Shadow (gets bigger when ball is higher)
          int shadow_y = 48;
          int shadow_w = 12 + (int)(bounce_height * 8);
          it.filled_rectangle(20 - shadow_w / 2, shadow_y, shadow_w, 2, Color(0, 50, 50, 100));

          // Ball with gradient (brighter at top)
          Color ball_color = Color(0, 200 + (int)(bounce_height * 55), 255);
          it.filled_circle(20, ball_y, ball_size, ball_color);
          // Highlight
          it.filled_circle(20 - 2, ball_y - 2, 2, Color(150, 255, 255));

          return;
      }

      // === IDLE / HOME SCREEN - Clean with accent ===
      if (mode == "IDLE" || msg == "CLAWDBOT READY" || msg.empty()) {
          // Cute robot eyes that blink occasionally
          int blink_cycle = (millis() / 100) % 50;  // Every 5 seconds
          bool is_blinking = (blink_cycle < 2);  // Blink for 200ms

          // Left eye
          int left_eye_x = 30;
          int left_eye_y = 15;
          if (is_blinking) {
              // Closed (just a line)
              it.line(left_eye_x - 5, left_eye_y, left_eye_x + 5, left_eye_y, CYAN);
          } else {
              // Open (circle with pupil)
              it.filled_circle(left_eye_x, left_eye_y, 6, Color(20, 20, 40));
              it.circle(left_eye_x, left_eye_y, 6, CYAN);
              it.filled_circle(left_eye_x, left_eye_y, 3, CYAN);
              it.filled_circle(left_eye_x - 1, left_eye_y - 1, 1, Color(150, 255, 255));
          }

          // Right eye
          int right_eye_x = 210;
          int right_eye_y = 15;
          if (is_blinking) {
              it.line(right_eye_x - 5, right_eye_y, right_eye_x + 5, right_eye_y, CYAN);
          } else {
              it.filled_circle(right_eye_x, right_eye_y, 6, Color(20, 20, 40));
              it.circle(right_eye_x, right_eye_y, 6, CYAN);
              it.filled_circle(right_eye_x, right_eye_y, 3, CYAN);
              it.filled_circle(right_eye_x - 1, right_eye_y - 1, 1, Color(150, 255, 255));
          }

          // Subtle top accent line
          it.line(40, 8, 200, 8, TEAL);

          // Large clock - white for readability
          it.strftime(120, 45, id(font_large), Color::WHITE, TextAlign::CENTER, "%H:%M", id(sntp_time).now());

          // Accent divider
          it.line(60, 78, 180, 78, CYAN);

          // Weather in teal if available
          std::string weather = id(weather_display).state;
          if (!weather.empty()) {
            it.print(120, 92, id(font_body), TEAL, TextAlign::CENTER, weather.c_str());
          }

          // Bottom status bar
          if (id(battery_level).has_state()) {
            float batt = id(battery_level).state;
            Color batt_color = (batt > 50) ? LIME : ((batt > 20) ? AMBER : RED);
            it.printf(120, 120, id(font_small), batt_color, TextAlign::CENTER, "%.0f%%", batt);

            // Battery bar
            int bar_width = (batt / 100.0) * 40;
            it.rectangle(100, 130, 40, 4, DIM);
            it.filled_rectangle(100, 130, bar_width, 4, batt_color);
          }

          // Connection pulse - cyan
          if (id(pulse_state)) {
            it.filled_circle(120, 4, 2, CYAN);
          }

          // Lobster icon hint (small)
          it.print(10, 120, id(font_small), CORAL, TextAlign::TOP_LEFT, ">");
          return;
      }

      // === ALERT MODE - Red urgency ===
      if (mode == "ALERT") {
          // Flashing red header
          Color header_color = id(pulse_state) ? RED : ORANGE;
          it.filled_rectangle(0, 0, 240, 28, header_color);
          it.print(120, 6, id(font_body), Color::WHITE, TextAlign::TOP_CENTER, "! ALERT !");

          // Message in white on dark
          std::string clean_msg = "";
          for (char c : msg) {
            if (c == '\n' || (c >= 32 && c <= 126)) clean_msg += c;
          }

          std::vector<std::string> lines;
          size_t start = 0, end;
          while ((end = clean_msg.find('\n', start)) != std::string::npos) {
              lines.push_back(clean_msg.substr(start, end - start));
              start = end + 1;
          }
          lines.push_back(clean_msg.substr(start));

          int y = 45;
          for (const auto& line : lines) {
              if (line.empty()) { y += 12; continue; }
              it.print(120, y, id(font_body), Color::WHITE, TextAlign::CENTER, line.c_str());
              y += 22;
          }
          return;
      }

      // === RESPONSE MODE - Clean with coral accent ===
      // Header bar with time and battery
      it.filled_rectangle(0, 0, 240, 22, Color(20, 20, 30));
      it.line(0, 22, 240, 22, CORAL);
      it.strftime(8, 4, id(font_small), DIM, TextAlign::TOP_LEFT, "%H:%M", id(sntp_time).now());
      it.print(120, 4, id(font_small), CORAL, TextAlign::TOP_CENTER, "CLAWDBOT");

      if (id(battery_level).has_state()) {
        it.printf(232, 4, id(font_small), DIM, TextAlign::TOP_RIGHT, "%.0f%%", id(battery_level).state);
      }

      // Sanitize and display message
      std::string clean_msg = "";
      for (char c : msg) {
        if (c == '\n' || (c >= 32 && c <= 126)) clean_msg += c;
      }

      std::vector<std::string> lines;
      size_t start = 0, end;
      while ((end = clean_msg.find('\n', start)) != std::string::npos) {
          lines.push_back(clean_msg.substr(start, end - start));
          start = end + 1;
      }
      lines.push_back(clean_msg.substr(start));

      // Center content vertically
      int y = (lines.size() > 4) ? 28 : ((lines.size() > 2) ? 40 : 55);
      for (const auto& line : lines) {
          if (line.empty()) { y += 12; continue; }
          it.print(120, y, id(font_body), Color::WHITE, TextAlign::CENTER, line.c_str());
          y += 22;
      }

font:
  - file: "gfonts://Roboto Mono"
    id: font_large
    size: 38
  - file: "gfonts://Roboto Mono"
    id: font_body
    size: 16
  - file: "gfonts://Roboto Mono"
    id: font_small
    size: 10
