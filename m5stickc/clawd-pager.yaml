esphome:
  name: clawd-pager
  friendly_name: "Clawd Pager"
  includes:
    - audio_streamer.h
  on_boot:
    priority: -10
    then:
      # Fun Mario-style startup jingle!
      - rtttl.play: "Mario:d=4,o=5,b=200:e6,8e6,8e6,8c6,e6,g6,g"
      - text_sensor.template.publish:
          id: pager_display
          state: "LOBSTER READY!"
      - text_sensor.template.publish:
          id: display_mode
          state: "IDLE"
      - text_sensor.template.publish:
          id: weather_display
          state: ""
      - lambda: |-
          // Initialize audio streamer with bridge IP and port
          audio_streamer().begin("192.168.50.50", 12345);

esp32:
  board: m5stick-c
  framework:
    type: arduino

external_components:
  # Using makerwolf fork for charging detection support
  - source: github://makerwolf/esphome-axp192
    components: [axp192]

i2c:
  sda: 21
  scl: 22

# I2S Audio for PDM microphone (SPM1423)
# M5StickC Plus 1.1: CLK=GPIO0, Data=GPIO34
# NOTE: Buzzer must be OFF during recording - they share resources!
i2s_audio:
  - id: mic_i2s_bus
    i2s_lrclk_pin:
      number: GPIO0
      ignore_strapping_warning: true

microphone:
  - platform: i2s_audio
    id: mic_i2s
    i2s_audio_id: mic_i2s_bus
    i2s_din_pin: GPIO34
    adc_type: external
    pdm: true
    channel: left
    on_data:
      - lambda: |-
          // Stream audio via UDP to bridge when recording
          if (id(is_recording) && x.size() > 0) {
            audio_streamer().send_audio(x.data(), x.size());
          }

logger:
  level: DEBUG

api:
  services:
    # Main display update service - called by bridge
    # Modes starting with "SILENT_" skip the beep but show correct display
    - service: set_display
      variables:
        my_text: string
        my_mode: string
      then:
        - text_sensor.template.publish:
            id: pager_display
            state: !lambda "return my_text;"
        - lambda: |-
            // Handle SILENT_ prefix: strip it and skip beep
            std::string mode = my_mode;
            bool silent = false;
            if (mode.substr(0, 7) == "SILENT_") {
                mode = mode.substr(7);  // Strip "SILENT_" prefix
                silent = true;
            }
            id(display_mode).publish_state(mode);
        - if:
            condition:
              lambda: |-
                std::string mode = my_mode;
                // No beep if SILENT or SILENT_ prefixed
                return mode != "SILENT" && mode.substr(0, 7) != "SILENT_";
            then:
              - rtttl.play: "Blip:d=32,o=6,b=150:c6"
        - script.execute: activity_watcher
    
    # Weather widget update
    - service: update_weather
      variables:
        my_weather: string
      then:
        - text_sensor.template.publish:
            id: weather_display
            state: !lambda "return my_weather;"
    
    # Alert with distinct tone
    - service: alert
      variables:
        my_text: string
      then:
        - rtttl.play: "Alert:d=16,o=6,b=180:c,e,g,c7"
        - text_sensor.template.publish:
            id: pager_display
            state: !lambda "return my_text;"
        - text_sensor.template.publish:
            id: display_mode
            state: "ALERT"
        - script.execute: activity_watcher
        - lambda: |-
            if (id(dev_mode)) {
              id(event_seq)++;
              ESP_LOGI("EVENT", "[%d] ALERT | text=%s", id(event_seq), my_text.c_str());
            }

    # Toggle development mode (verbose logging)
    - service: set_dev_mode
      variables:
        enabled: bool
      then:
        - globals.set:
            id: dev_mode
            value: !lambda "return enabled;"
        - lambda: |-
            ESP_LOGI("EVENT", "DEV_MODE %s", enabled ? "ENABLED" : "DISABLED");

    # Get current device state (for dashboard polling)
    - service: get_state
      then:
        - lambda: |-
            ESP_LOGI("STATE", "mode=%s battery=%.0f dev_mode=%s",
                     id(display_mode).state.c_str(),
                     id(battery_level).has_state() ? id(battery_level).state : 0.0,
                     id(dev_mode) ? "true" : "false");

ota:
  - platform: esphome

wifi:
  ssid: "FlyingChanges"
  password: "flyingchanges"
  fast_connect: true
  power_save_mode: none

time:
  - platform: sntp
    id: sntp_time
    timezone: "EST5EDT,M3.2.0,M11.1.0"

output:
  - platform: ledc
    id: buzzer_pwm
    pin: GPIO2

rtttl:
  output: buzzer_pwm
  id: buzzer

sensor:
  - platform: axp192
    model: M5STICKC
    address: 0x34
    id: my_axp
    battery_level:
      name: "Battery"
      id: battery_level

binary_sensor:
  # Charging detection via template - polls AXP192 charging status
  - platform: template
    name: "Charging"
    id: is_charging
    lambda: |-
      // Check if battery is charging by comparing voltage/current
      // AXP192 reports charging when VBUS is present and battery < 100%
      return id(battery_level).state < 99.0;
    on_press:
      then:
        - lambda: |-
            if (id(dev_mode)) {
              id(event_seq)++;
              ESP_LOGI("EVENT", "[%d] CHARGING_START", id(event_seq));
            }
            // Full brightness when charging - we have power!
            id(my_axp).set_brightness(1.0);
        - if:
            condition:
              lambda: 'return id(display_mode).state == "IDLE";'
            then:
              - text_sensor.template.publish:
                  id: display_mode
                  state: "DOCKED"
    on_release:
      then:
        - lambda: |-
            if (id(dev_mode)) {
              id(event_seq)++;
              ESP_LOGI("EVENT", "[%d] CHARGING_STOP", id(event_seq));
            }
        - if:
            condition:
              lambda: 'return id(display_mode).state == "DOCKED";'
            then:
              - text_sensor.template.publish:
                  id: display_mode
                  state: "IDLE"

  # Button A - YES / CONFIRM / VOICE (hold)
  # New ergonomic layout: A is the main action button
  - platform: gpio
    pin:
      number: GPIO37
      inverted: true
    name: "Button A"
    id: button_a
    on_multi_click:
      # Short tap = Context-aware action
      - timing:
          - ON for at most 400ms
          - OFF for at least 50ms
        then:
          - lambda: |-
              std::string mode = id(display_mode).state;
              if (id(dev_mode)) {
                id(event_seq)++;
                ESP_LOGI("EVENT", "[%d] BUTTON_A_TAP | mode=%s", id(event_seq), mode.c_str());
              }
          - script.execute: activity_watcher
          - if:
              condition:
                lambda: 'return id(display_mode).state == "QUESTION";'
              then:
                # YES response - Zelda "item get" style!
                - rtttl.play: "Yes:d=16,o=5,b=200:g,c6,e6,g6,8e6,8g6"
                - text_sensor.template.publish:
                    id: pager_display
                    state: "YES!"
                - text_sensor.template.publish:
                    id: display_mode
                    state: "RESPONSE"
          - if:
              condition:
                lambda: 'return id(display_mode).state == "PERMISSION";'
              then:
                # APPROVED - triumphant sound!
                - rtttl.play: "Approved:d=16,o=5,b=180:c,e,g,c6,8g,8c6"
                - text_sensor.template.publish:
                    id: pager_display
                    state: "APPROVED"
                - text_sensor.template.publish:
                    id: display_mode
                    state: "PERM_APPROVED"
          - if:
              condition:
                lambda: 'return id(display_mode).state == "CONFIRM";'
              then:
                # SEND - whoosh sound!
                - rtttl.play: "Send:d=32,o=5,b=300:c,d,e,f,g,a,b,c6,d6,e6"
                - text_sensor.template.publish:
                    id: pager_display
                    state: "SENDING..."
                - text_sensor.template.publish:
                    id: display_mode
                    state: "PROCESSING"
          - if:
              condition:
                lambda: 'return id(display_mode).state == "IDLE" || id(display_mode).state == "DOCKED";'
              then:
                # Get STATUS from Clawdbot
                - rtttl.play: "Blip:d=32,o=6,b=150:c6"
                - text_sensor.template.publish:
                    id: pager_display
                    state: "Getting status..."
                - text_sensor.template.publish:
                    id: display_mode
                    state: "PROCESSING"
      # Long hold (400ms+) = VOICE recording
      - timing:
          - ON for at least 400ms
        then:
          # Fun "listening" chirp!
          - rtttl.play: "Listen:d=16,o=6,b=200:c,g,c7"
          - delay: 100ms
          # CRITICAL: Stop buzzer before recording - they share resources!
          - output.turn_off: buzzer_pwm
          - globals.set:
              id: btn_a_pressed
              value: 'true'
          - globals.set:
              id: is_recording
              value: 'true'
          - text_sensor.template.publish:
              id: display_mode
              state: "LISTENING"
          - text_sensor.template.publish:
              id: pager_display
              state: "LISTENING..."
          - script.execute: activity_watcher
          - lambda: |-
              audio_streamer().start_recording();
              if (id(dev_mode)) {
                id(event_seq)++;
                ESP_LOGI("EVENT", "[%d] BUTTON_A_HOLD | mode=LISTENING", id(event_seq));
              }
          - microphone.capture: mic_i2s
    on_release:
      then:
        - if:
            condition:
              lambda: 'return id(btn_a_pressed);'
            then:
              - microphone.stop_capture: mic_i2s
              - lambda: |-
                  id(is_recording) = false;
                  audio_streamer().stop_recording();
                  ESP_LOGI("AUDIO", "Sent %d bytes", audio_streamer().bytes_sent());
              # Satisfying "got it!" chirps
              - rtttl.play: "Done:d=16,o=6,b=200:c,e,c"
              - globals.set:
                  id: btn_a_pressed
                  value: 'false'
              - text_sensor.template.publish:
                  id: display_mode
                  state: "PROCESSING"
              - text_sensor.template.publish:
                  id: pager_display
                  state: "PROCESSING..."
              - lambda: |-
                  if (id(dev_mode)) {
                    id(event_seq)++;
                    ESP_LOGI("EVENT", "[%d] BUTTON_A_RELEASE | mode=PROCESSING | bytes=%d", id(event_seq), audio_streamer().bytes_sent());
                  }

  # Button B - NO / BACK / CANCEL
  - platform: gpio
    pin:
      number: GPIO39
      inverted: true
    name: "Button B"
    id: button_b
    on_click:
      min_length: 50ms
      max_length: 500ms
      then:
        - lambda: |-
            std::string mode = id(display_mode).state;
            if (id(dev_mode)) {
              id(event_seq)++;
              ESP_LOGI("EVENT", "[%d] BUTTON_B_TAP | mode=%s", id(event_seq), mode.c_str());
            }
        - script.execute: activity_watcher
        - if:
            condition:
              lambda: 'return id(display_mode).state == "QUESTION";'
            then:
              # NO response - sad trombone wah wah!
              - rtttl.play: "No:d=8,o=5,b=120:b,4a#,4a,2g#"
              - text_sensor.template.publish:
                  id: pager_display
                  state: "NO"
              - text_sensor.template.publish:
                  id: display_mode
                  state: "RESPONSE"
        - if:
            condition:
              lambda: 'return id(display_mode).state == "PERMISSION";'
            then:
              # DENIED - warning buzz
              - rtttl.play: "Denied:d=8,o=4,b=100:c,p,c,p,c"
              - text_sensor.template.publish:
                  id: pager_display
                  state: "DENIED"
              - text_sensor.template.publish:
                  id: display_mode
                  state: "PERM_DENIED"
        - if:
            condition:
              lambda: 'return id(display_mode).state == "CONFIRM";'
            then:
              # CANCEL - don't send
              - rtttl.play: "Cancel:d=16,o=5,b=200:c,c"
              - text_sensor.template.publish:
                  id: pager_display
                  state: "Cancelled"
              - delay: 500ms
              - text_sensor.template.publish:
                  id: display_mode
                  state: "IDLE"
              - text_sensor.template.publish:
                  id: pager_display
                  state: "CLAWDBOT READY"
        - if:
            condition:
              lambda: |-
                std::string m = id(display_mode).state;
                return m != "QUESTION" && m != "CONFIRM" && m != "IDLE";
            then:
              # BACK to home
              - rtttl.play: "Back:d=32,o=5,b=150:c"
              - text_sensor.template.publish:
                  id: display_mode
                  state: "IDLE"
              - text_sensor.template.publish:
                  id: pager_display
                  state: "CLAWDBOT READY"

  # Power Button (GPIO35) - Handled by AXP192 hardware, not addressable via GPIO
  # Physical button: short press = wake, long press (6s) = power off

# Text sensors - exposed to bridge
text_sensor:
  - platform: template
    id: pager_display
    name: "Pager Display"
  - platform: template
    id: weather_display
    name: "Weather Display"
  - platform: template
    id: display_mode
    name: "Display Mode"

globals:
  - id: pulse_state
    type: bool
    initial_value: 'false'
  - id: btn_a_pressed
    type: bool
    initial_value: 'false'
  - id: btn_b_pressed
    type: bool
    initial_value: 'false'
  # Development mode - enables verbose event logging
  - id: dev_mode
    type: bool
    initial_value: 'true'
  # Event sequence counter for ordering
  - id: event_seq
    type: int
    initial_value: '0'
  # Audio recording state
  - id: is_recording
    type: bool
    initial_value: 'false'

script:
  - id: activity_watcher
    mode: restart
    then:
      - lambda: |-
          id(my_axp).set_brightness(1.0);
      - delay: 30s
      - lambda: |-
          // Don't dim if docked OR battery nearly full (plugged in and charged)
          bool has_power = (id(display_mode).state == "DOCKED") ||
                           (id(battery_level).has_state() && id(battery_level).state >= 95.0);
          if (!has_power) {
            id(my_axp).set_brightness(0.4);
          }
      - delay: 30s
      - lambda: |-
          // Don't dim if docked OR battery nearly full
          bool has_power = (id(display_mode).state == "DOCKED") ||
                           (id(battery_level).has_state() && id(battery_level).state >= 95.0);
          if (!has_power) {
            id(my_axp).set_brightness(0.1);
          }
      - delay: 120s
      - lambda: |-
          // Auto power off after 3 minutes total inactivity
          // Skip if charging/docked
          bool has_power = (id(display_mode).state == "DOCKED") ||
                           (id(battery_level).has_state() && id(battery_level).state >= 95.0);
          if (!has_power) {
            ESP_LOGI("POWER", "Auto power off after 3 min inactivity");
            // Power off via AXP192 register 0x32, bit 7
            // Write to I2C address 0x34, register 0x32, value 0x80
            Wire.beginTransmission(0x34);
            Wire.write(0x32);
            Wire.write(0x80);  // Bit 7 = power off
            Wire.endTransmission();
          }

spi:
  clk_pin: GPIO13
  mosi_pin: GPIO15

display:
  - platform: st7789v
    model: TTGO_TDisplay_135x240
    cs_pin: GPIO5
    dc_pin: GPIO23
    reset_pin: GPIO18
    rotation: 270
    update_interval: 0.5s
    lambda: |-
      // === COLOR PALETTE ===
      Color CYAN = Color(0, 255, 255);
      Color TEAL = Color(0, 200, 200);
      Color CORAL = Color(255, 127, 80);
      Color AMBER = Color(255, 191, 0);
      Color LIME = Color(50, 205, 50);
      Color PINK = Color(255, 105, 180);
      Color PURPLE = Color(147, 112, 219);
      Color RED = Color(255, 60, 60);
      Color ORANGE = Color(255, 140, 0);
      Color DIM = Color(100, 100, 100);

      it.fill(Color::BLACK);
      id(pulse_state) = !id(pulse_state);
      int frame = (millis() / 100) % 20;  // Animation frame

      std::string mode = id(display_mode).state;
      std::string msg = id(pager_display).state;

      // === LISTENING MODE - Rainbow waveform (Pixar-style!) ===
      if (mode == "LISTENING") {
          // Rainbow colors for bars
          Color rainbow[] = {
            Color(255, 50, 50),    // Red
            Color(255, 150, 0),    // Orange
            Color(255, 220, 0),    // Yellow
            Color(100, 255, 50),   // Lime
            Color(0, 220, 180),    // Teal
            Color(50, 150, 255),   // Blue
            Color(150, 100, 255),  // Purple
            Color(255, 100, 200),  // Pink
            Color(255, 150, 0),    // Orange
            Color(255, 220, 0),    // Yellow
            Color(100, 255, 50),   // Lime
            Color(0, 220, 180)     // Teal
          };

          // Bouncy rainbow waveform
          for (int i = 0; i < 12; i++) {
            int phase = (frame + i * 3) % 20;
            int h = 10 + abs(10 - phase) * 3;
            it.filled_rectangle(25 + i * 17, 68 - h, 12, h * 2, rainbow[i]);
          }

          // Cute bouncing mic icon (circle with lines)
          int bounce = abs((frame % 10) - 5);
          it.filled_circle(120, 115 + bounce, 8, Color::WHITE);
          it.filled_rectangle(117, 123 + bounce, 6, 8, Color::WHITE);

          return;
      }

      // === CONFIRM MODE - Show transcription, confirm before sending ===
      if (mode == "CONFIRM") {
          // Header with teal gradient effect
          it.filled_rectangle(0, 0, 240, 22, TEAL);
          it.print(120, 4, id(font_body), Color::BLACK, TextAlign::TOP_CENTER, "CONFIRM?");

          // Transcription text (the message contains what was heard)
          std::string clean_msg = "";
          for (char c : msg) {
            if (c == '\n' || (c >= 32 && c <= 126)) clean_msg += c;
          }

          // Word wrap the transcription
          std::vector<std::string> lines;
          std::string current_line = "";
          for (size_t i = 0; i < clean_msg.length(); i++) {
            current_line += clean_msg[i];
            if (current_line.length() > 22 || clean_msg[i] == '\n') {
              lines.push_back(current_line);
              current_line = "";
            }
          }
          if (!current_line.empty()) lines.push_back(current_line);

          // Display transcription in white
          int y = 30;
          for (size_t i = 0; i < lines.size() && i < 4; i++) {
            it.print(120, y, id(font_body), Color::WHITE, TextAlign::CENTER, lines[i].c_str());
            y += 18;
          }

          // Button hints with pulsing animation
          int pulse_frame = (millis() / 400) % 6;

          // A = SEND (green, left side)
          Color send_color = (pulse_frame < 3) ? LIME : Color(30, 150, 30);
          it.filled_rectangle(15, 108, 100, 24, send_color);
          it.print(65, 113, id(font_body), Color::BLACK, TextAlign::CENTER, "A = SEND");

          // B = CANCEL (coral, right side)
          Color cancel_color = (pulse_frame >= 3) ? CORAL : Color(180, 80, 50);
          it.filled_rectangle(125, 108, 100, 24, cancel_color);
          it.print(175, 113, id(font_body), Color::BLACK, TextAlign::CENTER, "B = CANCEL");

          return;
      }

      // === PROCESSING MODE - Colorful bouncing dots ===
      if (mode == "PROCESSING") {
          // Rainbow bouncing dots instead of boring spinner
          Color dot_colors[] = {
            Color(255, 50, 50),    // Red
            Color(255, 150, 0),    // Orange
            Color(255, 220, 0),    // Yellow
            Color(100, 255, 50),   // Lime
            Color(0, 200, 220),    // Cyan
            Color(100, 100, 255),  // Blue
            Color(200, 100, 255),  // Purple
            Color(255, 100, 200)   // Pink
          };

          // Bouncing dots in a wave with shadows and glow
          for (int i = 0; i < 8; i++) {
            int bounce = abs(((frame * 2 + i * 5) % 30) - 15);
            int x = 50 + i * 22;
            int y = 55 + bounce;
            int size = 6 + (bounce / 5);

            // Shadow below (gets bigger when higher)
            int shadow_y = 70;
            int shadow_w = (size + 2) * 2;
            it.filled_rectangle(x - shadow_w / 2, shadow_y, shadow_w, 2, Color(0, 0, 0, 100));

            // Glow/halo effect
            Color glow_color = dot_colors[i];
            glow_color.r /= 3; glow_color.g /= 3; glow_color.b /= 3;
            it.filled_circle(x, y, size + 2, glow_color);

            // Main dot
            it.filled_circle(x, y, size, dot_colors[i]);

            // Highlight
            it.filled_circle(x - 1, y - 1, 2, Color(255, 255, 255));
          }

          it.print(120, 100, id(font_body), AMBER, TextAlign::CENTER, "PROCESSING");
          it.print(120, 120, id(font_small), DIM, TextAlign::CENTER, "Thinking...");
          return;
      }

      // === AWAITING MODE - Purple pulse ===
      if (mode == "AWAITING") {
          it.print(120, 35, id(font_body), PURPLE, TextAlign::CENTER, "AWAITING");
          it.print(120, 55, id(font_body), PURPLE, TextAlign::CENTER, "RESPONSE");

          // Pulsing concentric circles
          int pulse_size = 5 + (frame % 10) * 2;
          it.circle(120, 95, pulse_size, PURPLE);
          it.circle(120, 95, pulse_size + 8, PINK);
          if (id(pulse_state)) {
            it.filled_circle(120, 95, 4, PURPLE);
          }
          return;
      }

      // === DOCKED MODE - Ambient display when charging ===
      if (mode == "DOCKED") {
          // Dark ambient background with floating particles
          int slow_frame = (millis() / 200) % 100;

          // Orbiting particles around center
          for (int i = 0; i < 6; i++) {
            float angle = (i * 60 + slow_frame * 3.6) * 3.14159 / 180;
            int radius = 35 + (i % 2) * 15;
            int x = 120 + cos(angle) * radius;
            int y = 68 + sin(angle) * (radius / 2);  // Elliptical orbit
            Color particle_color = (i % 3 == 0) ? CYAN : ((i % 3 == 1) ? PURPLE : PINK);
            int size = 2 + (slow_frame + i * 16) % 3;
            it.filled_circle(x, y, size, particle_color);
          }

          // Gentle clock in center
          it.strftime(120, 50, id(font_large), CYAN, TextAlign::CENTER, "%H:%M", id(sntp_time).now());

          // Subtle "DOCKED" indicator
          it.print(120, 95, id(font_small), DIM, TextAlign::CENTER, "DOCKED");

          // Charging indicator - animated lightning bolt effect
          int bolt_y = 115 + (slow_frame % 10 < 5 ? 0 : 2);
          it.print(110, bolt_y, id(font_small), LIME, TextAlign::CENTER, "++");

          // Battery with fill animation
          if (id(battery_level).has_state()) {
            float batt = id(battery_level).state;
            int fill = (int)(batt / 100.0 * 30) + (slow_frame % 5);
            if (fill > 30) fill = 30;
            it.rectangle(105, 125, 30, 8, LIME);
            it.filled_rectangle(105, 125, fill, 8, LIME);
            it.printf(140, 125, id(font_small), LIME, "%.0f%%", batt);
          }
          return;
      }

      // === PERMISSION MODE - Claude Code needs approval for a tool ===
      if (mode == "PERMISSION") {
          int perm_frame = (millis() / 200) % 20;

          // Urgent pulsing red/orange header
          Color header_color = (perm_frame < 10) ? RED : ORANGE;
          it.filled_rectangle(0, 0, 240, 28, header_color);
          it.print(120, 6, id(font_body), Color::WHITE, TextAlign::TOP_CENTER, "APPROVE?");

          // Parse message: line1=header, line2=tool, line3=command
          std::vector<std::string> lines;
          std::string current = "";
          for (char c : msg) {
              if (c == '\n') {
                  if (!current.empty()) lines.push_back(current);
                  current = "";
              } else if (c >= 32 && c <= 126) {
                  current += c;
              }
          }
          if (!current.empty()) lines.push_back(current);

          // Display tool name
          if (lines.size() > 1) {
              std::string tool = lines[1];
              if (tool.length() > 24) tool = tool.substr(0, 24);
              it.print(120, 35, id(font_body), CYAN, TextAlign::CENTER, tool.c_str());
          }

          // Display command preview (scrolling if long)
          if (lines.size() > 2) {
              std::string cmd = lines[2];
              if (cmd.length() > 26) {
                  int scroll = (perm_frame / 2) % (cmd.length() - 24);
                  cmd = cmd.substr(scroll, 26);
              }
              it.print(120, 58, id(font_small), DIM, TextAlign::CENTER, cmd.c_str());
          }

          // Big YES / NO buttons with pulsing highlight
          int pulse = (perm_frame < 10) ? 0 : 5;

          // A = YES (green, left)
          Color yes_bg = (perm_frame < 10) ? LIME : Color(30, 180, 30);
          it.filled_rectangle(15 - pulse, 85, 100 + pulse * 2, 40, yes_bg);
          it.print(65, 97, id(font_body), Color::BLACK, TextAlign::CENTER, "A = YES");

          // B = NO (red, right)
          Color no_bg = (perm_frame >= 10) ? RED : Color(180, 30, 30);
          it.filled_rectangle(125 - pulse, 85, 100 + pulse * 2, 40, no_bg);
          it.print(175, 97, id(font_body), Color::WHITE, TextAlign::CENTER, "B = NO");

          return;
      }

      // === QUESTION MODE - Claude Code is asking something ===
      if (mode == "QUESTION") {
          int pulse_frame = (millis() / 300) % 10;

          // Attention-getting header
          Color question_color = id(pulse_state) ? AMBER : ORANGE;
          it.filled_rectangle(0, 0, 240, 25, question_color);
          it.print(120, 5, id(font_body), Color::BLACK, TextAlign::TOP_CENTER, "CLAUDE ASKS");

          // Question text with word wrapping
          std::string clean_msg = "";
          for (char c : msg) {
            if (c == '\n' || (c >= 32 && c <= 126)) clean_msg += c;
          }

          // Word wrap at 24 chars (safe for 240px screen with 16px font)
          std::vector<std::string> lines;
          const int MAX_CHARS = 24;

          // Split by newlines first, then wrap each paragraph
          size_t para_start = 0, para_end;
          while ((para_end = clean_msg.find('\n', para_start)) != std::string::npos) {
              std::string para = clean_msg.substr(para_start, para_end - para_start);
              if (!para.empty()) {
                  // Wrap this paragraph
                  std::string current_line = "";
                  size_t word_start = 0;
                  while (word_start < para.length()) {
                      size_t word_end = para.find(' ', word_start);
                      if (word_end == std::string::npos) word_end = para.length();
                      std::string word = para.substr(word_start, word_end - word_start);

                      if (current_line.empty()) {
                          current_line = word;
                      } else if (current_line.length() + 1 + word.length() <= MAX_CHARS) {
                          current_line += " " + word;
                      } else {
                          lines.push_back(current_line);
                          current_line = word;
                      }
                      word_start = (word_end == para.length()) ? word_end : word_end + 1;
                  }
                  if (!current_line.empty()) lines.push_back(current_line);
              }
              para_start = para_end + 1;
          }
          // Handle last paragraph
          std::string para = clean_msg.substr(para_start);
          if (!para.empty()) {
              std::string current_line = "";
              size_t word_start = 0;
              while (word_start < para.length()) {
                  size_t word_end = para.find(' ', word_start);
                  if (word_end == std::string::npos) word_end = para.length();
                  std::string word = para.substr(word_start, word_end - word_start);

                  if (current_line.empty()) {
                      current_line = word;
                  } else if (current_line.length() + 1 + word.length() <= MAX_CHARS) {
                      current_line += " " + word;
                  } else {
                      lines.push_back(current_line);
                      current_line = word;
                  }
                  word_start = (word_end == para.length()) ? word_end : word_end + 1;
              }
              if (!current_line.empty()) lines.push_back(current_line);
          }

          // Auto-scroll if more than 3 lines (fits in y=35 to y=95)
          const int MAX_VISIBLE_LINES = 3;
          int scroll_offset = 0;
          if (lines.size() > MAX_VISIBLE_LINES) {
              // Scroll every 2.5 seconds
              int scroll_index = (millis() / 2500) % lines.size();
              scroll_offset = scroll_index;
          }

          int y = 35;
          int displayed = 0;
          for (size_t i = scroll_offset; i < lines.size() && displayed < MAX_VISIBLE_LINES; i++) {
              if (lines[i].empty()) { y += 12; continue; }
              it.print(120, y, id(font_body), Color::WHITE, TextAlign::CENTER, lines[i].c_str());
              y += 20;
              displayed++;
          }

          // Flashing button hint
          if (pulse_frame < 5) {
            it.filled_rectangle(60, 115, 120, 20, LIME);
            it.print(120, 118, id(font_body), Color::BLACK, TextAlign::CENTER, "Press A = YES");
          } else {
            it.rectangle(60, 115, 120, 20, LIME);
            it.print(120, 118, id(font_body), LIME, TextAlign::CENTER, "Press A = YES");
          }
          return;
      }

      // === AGENT_EDIT MODE - File editing with diff stats ===
      if (mode == "AGENT_EDIT") {
          int edit_frame = (millis() / 100) % 20;

          // Parse message: line1=filename, line2=diff stats, line3=code preview
          std::vector<std::string> lines;
          std::string current = "";
          for (char c : msg) {
              if (c == '\n') {
                  lines.push_back(current);
                  current = "";
              } else if (c >= 32 && c <= 126) {
                  current += c;
              }
          }
          if (!current.empty()) lines.push_back(current);

          std::string filename = lines.size() > 0 ? lines[0] : "file";
          std::string diff_stats = lines.size() > 1 ? lines[1] : "";
          std::string code_preview = lines.size() > 2 ? lines[2] : "";

          // Determine accent color from diff stats
          Color accent = AMBER;  // Default: modification
          bool has_add = diff_stats.find("+") != std::string::npos;
          bool has_del = diff_stats.find("-") != std::string::npos;
          if (has_add && !has_del) {
              accent = LIME;  // Pure additions
          } else if (has_del && !has_add) {
              accent = RED;   // Pure deletions
          } else if (has_add && has_del) {
              // Mixed - check which is bigger
              int add_count = 0, del_count = 0;
              size_t plus_pos = diff_stats.find("+");
              size_t minus_pos = diff_stats.find("-");
              if (plus_pos != std::string::npos) {
                  add_count = atoi(diff_stats.c_str() + plus_pos + 1);
              }
              if (minus_pos != std::string::npos) {
                  del_count = atoi(diff_stats.c_str() + minus_pos + 1);
              }
              if (add_count > del_count) accent = LIME;
              else if (del_count > add_count) accent = RED;
          }

          // Header bar with accent color
          it.filled_rectangle(0, 0, 240, 22, accent);
          it.print(120, 4, id(font_body), Color::BLACK, TextAlign::TOP_CENTER, "EDITING");

          // Filename - large and prominent
          if (filename.length() > 22) filename = filename.substr(0, 22);
          it.print(120, 30, id(font_body), Color::WHITE, TextAlign::CENTER, filename.c_str());

          // Diff stats - show +X and -Y separately with colors
          if (!diff_stats.empty()) {
              // Parse and display add/remove separately
              int y_stats = 52;
              size_t plus_pos = diff_stats.find("+");
              size_t minus_pos = diff_stats.find("-");

              if (plus_pos != std::string::npos && minus_pos != std::string::npos) {
                  // Show both: green +X  red -Y
                  std::string add_part = "";
                  std::string del_part = "";
                  // Extract numbers
                  size_t i = plus_pos;
                  while (i < diff_stats.length() && (diff_stats[i] == '+' || isdigit(diff_stats[i]))) {
                      add_part += diff_stats[i++];
                  }
                  i = minus_pos;
                  while (i < diff_stats.length() && (diff_stats[i] == '-' || isdigit(diff_stats[i]))) {
                      del_part += diff_stats[i++];
                  }
                  it.print(90, y_stats, id(font_body), LIME, TextAlign::CENTER, add_part.c_str());
                  it.print(150, y_stats, id(font_body), RED, TextAlign::CENTER, del_part.c_str());
              } else {
                  // Just show the stats in accent color
                  it.print(120, y_stats, id(font_body), accent, TextAlign::CENTER, diff_stats.c_str());
              }
          }

          // Code preview box (if small change)
          if (!code_preview.empty()) {
              // Dark code box
              it.filled_rectangle(10, 72, 220, 28, Color(20, 20, 30));
              it.rectangle(10, 72, 220, 28, Color(60, 60, 80));

              // Code text - monospace style
              if (code_preview.length() > 28) {
                  // Scroll long code
                  int scroll = (edit_frame / 2) % (code_preview.length() - 26);
                  code_preview = code_preview.substr(scroll, 28);
              }
              it.print(20, 78, id(font_body), Color(150, 200, 150), TextAlign::TOP_LEFT, code_preview.c_str());
          }

          // Animated progress bar at bottom
          int bar_width = (edit_frame * 12) % 200;
          it.filled_rectangle(20, 108, bar_width, 6, accent);
          it.rectangle(20, 108, 200, 6, Color(40, 40, 50));

          return;
      }

      // === AGENT_NEW MODE - Creating new file ===
      if (mode == "AGENT_NEW") {
          int new_frame = (millis() / 150) % 20;

          // Sparkle effect for new file
          Color sparkles[] = {CYAN, Color::WHITE, PINK, CYAN};
          for (int i = 0; i < 8; i++) {
              int x = 30 + ((i * 47 + new_frame * 13) % 180);
              int y = 10 + ((i * 23 + new_frame * 7) % 25);
              int size = 1 + (new_frame + i) % 3;
              it.filled_circle(x, y, size, sparkles[i % 4]);
          }

          // File icon (simple doc shape)
          it.filled_rectangle(95, 45, 50, 60, Color(30, 30, 40));
          it.filled_rectangle(95, 45, 50, 15, CYAN);
          it.filled_rectangle(130, 45, 15, 15, Color(30, 30, 40));  // Folded corner

          // Plus sign
          it.filled_rectangle(115, 70, 20, 4, LIME);
          it.filled_rectangle(123, 62, 4, 20, LIME);

          // File name below
          std::string line1 = msg.substr(0, msg.find('\n'));
          it.print(120, 115, id(font_body), CYAN, TextAlign::CENTER, line1.c_str());

          return;
      }

      // === AGENT_BASH MODE - Terminal command ===
      if (mode == "AGENT_BASH") {
          int bash_frame = (millis() / 100) % 30;

          // Terminal background with subtle gradient
          it.filled_rectangle(5, 5, 230, 125, Color(15, 15, 20));
          it.rectangle(5, 5, 230, 125, ORANGE);

          // Terminal title bar
          it.filled_rectangle(5, 5, 230, 20, Color(50, 35, 15));
          it.print(120, 8, id(font_body), ORANGE, TextAlign::TOP_CENTER, "TERMINAL");

          // Parse message: line1 is command name, line2 is full command
          std::string line1 = msg;
          std::string line2 = "";
          size_t nl = msg.find('\n');
          if (nl != std::string::npos) {
              line1 = msg.substr(0, nl);
              line2 = msg.substr(nl + 1);
          }

          // Command name - LARGE and prominent
          if (line1.length() > 20) line1 = line1.substr(0, 20);
          it.print(15, 32, id(font_body), LIME, TextAlign::TOP_LEFT, "$");
          it.print(30, 32, id(font_body), CYAN, TextAlign::TOP_LEFT, line1.c_str());

          // Full command preview - USE BODY FONT for readability!
          if (!line2.empty()) {
              // Scroll long commands - show 22 chars max
              int scroll_offset = 0;
              if (line2.length() > 22) {
                  int total_scroll = line2.length() - 20;
                  scroll_offset = (bash_frame / 3) % (total_scroll + 8);
                  if (scroll_offset > total_scroll) scroll_offset = 0;
              }
              std::string visible = line2.substr(scroll_offset, 22);
              // Dim orange for the full command - readable!
              it.print(15, 55, id(font_body), Color(180, 120, 60), TextAlign::TOP_LEFT, visible.c_str());
          }

          // Running indicator - LARGER with animated dots
          std::string dots = "";
          for (int i = 0; i < (bash_frame / 5) % 4; i++) dots += ".";
          it.print(15, 82, id(font_body), Color(100, 100, 100), TextAlign::TOP_LEFT, ("Running" + dots).c_str());

          // Animated cursor block
          if (bash_frame < 15) {
              int cursor_x = 90;
              it.filled_rectangle(cursor_x, 82, 10, 16, ORANGE);
          }

          // Progress bar at bottom
          int bar_width = (bash_frame * 8) % 210;
          it.filled_rectangle(15, 110, bar_width, 6, Color(80, 50, 20));

          return;
      }

      // === AGENT_SEARCH MODE - Grep/Glob search ===
      if (mode == "AGENT_SEARCH") {
          int search_frame = (millis() / 80) % 40;

          // Purple header bar
          it.filled_rectangle(0, 0, 240, 22, PURPLE);
          it.print(120, 4, id(font_body), Color::WHITE, TextAlign::TOP_CENTER, "SEARCHING");

          // Scanning lines animation - in content area
          for (int i = 0; i < 6; i++) {
              int y = 30 + ((i * 15 + search_frame * 3) % 70);
              int alpha = 200 - abs(60 - y) * 2;
              if (alpha < 40) alpha = 40;
              Color line_color = Color(147 * alpha / 255, 112 * alpha / 255, 219 * alpha / 255);
              it.line(100, y, 230, y, line_color);
          }

          // Magnifying glass icon (left side)
          int glass_bounce = abs((search_frame % 20) - 10) / 3;
          it.circle(45, 55 + glass_bounce, 18, PURPLE);
          it.circle(45, 55 + glass_bounce, 17, PURPLE);
          it.line(58, 68 + glass_bounce, 75, 85 + glass_bounce, PURPLE);
          it.line(59, 69 + glass_bounce, 76, 86 + glass_bounce, PURPLE);

          // Search pattern - LARGER
          std::string line1 = msg.substr(0, msg.find('\n'));
          if (line1.length() > 16) line1 = line1.substr(0, 16) + "..";
          it.print(160, 45, id(font_body), Color::WHITE, TextAlign::CENTER, line1.c_str());

          // File pattern - USE BODY FONT
          std::string line2 = "";
          if (msg.find('\n') != std::string::npos) {
              line2 = msg.substr(msg.find('\n') + 1);
              if (line2.length() > 18) line2 = line2.substr(0, 18);
          }
          it.print(160, 70, id(font_body), Color(120, 100, 160), TextAlign::CENTER, line2.c_str());

          // Progress dots at bottom
          for (int i = 0; i < 5; i++) {
              Color dot_c = (i <= (search_frame / 8) % 5) ? PURPLE : Color(50, 40, 70);
              it.filled_circle(90 + i * 15, 115, 4, dot_c);
          }

          return;
      }

      // === AGENT_WEB MODE - Web fetch/search ===
      if (mode == "AGENT_WEB") {
          int web_frame = (millis() / 60) % 60;

          // Cyan header bar
          it.filled_rectangle(0, 0, 240, 22, CYAN);
          it.print(120, 4, id(font_body), Color::BLACK, TextAlign::TOP_CENTER, "WEB");

          // Globe animation (spinning dots) - left side
          for (int i = 0; i < 12; i++) {
              float angle = (i * 30 + web_frame * 6) * 3.14159 / 180;
              int x = 45 + cos(angle) * 22;
              int y = 60 + sin(angle) * 14;
              Color dot_color = (i % 2 == 0) ? CYAN : TEAL;
              it.filled_circle(x, y, 3, dot_color);
          }
          it.circle(45, 60, 22, CYAN);
          it.line(23, 60, 67, 60, TEAL);
          it.line(45, 38, 45, 82, TEAL);

          // URL/query text - LARGER
          std::string line1 = msg.substr(0, msg.find('\n'));
          if (line1.length() > 14) line1 = line1.substr(0, 14);
          it.print(155, 40, id(font_body), Color::WHITE, TextAlign::CENTER, line1.c_str());

          // URL preview - USE BODY FONT
          std::string line2 = "";
          if (msg.find('\n') != std::string::npos) {
              line2 = msg.substr(msg.find('\n') + 1);
              if (line2.length() > 16) {
                  // Scroll long URLs
                  int scroll = (web_frame / 4) % (line2.length() - 14);
                  line2 = line2.substr(scroll, 16);
              }
          }
          it.print(155, 65, id(font_body), Color(100, 180, 180), TextAlign::CENTER, line2.c_str());

          // Loading bar - animated bounce
          int bar_pos = (web_frame * 4) % 180;
          it.filled_rectangle(30, 100, 180, 8, Color(20, 50, 50));
          it.filled_rectangle(30 + bar_pos, 100, 40, 8, CYAN);

          // Fetching text
          it.print(120, 115, id(font_body), TEAL, TextAlign::CENTER, "Fetching...");

          return;
      }

      // === AGENT_SUB MODE - Sub-agent working ===
      if (mode == "AGENT_SUB") {
          int sub_frame = (millis() / 100) % 30;

          // Distinctive pink/purple header bar
          it.filled_rectangle(0, 0, 240, 25, PINK);
          it.print(120, 5, id(font_body), Color::BLACK, TextAlign::TOP_CENTER, "SUB-AGENT");

          // Multiple bouncing agents (dots) - smaller, in a row
          Color agent_colors[] = {PURPLE, CYAN, LIME, AMBER, PINK};
          for (int i = 0; i < 5; i++) {
              int bounce = abs(((sub_frame + i * 5) % 16) - 8);
              int x = 30 + i * 45;
              it.filled_circle(x, 42 + bounce, 6, agent_colors[i]);
              it.filled_circle(x - 1, 40 + bounce, 2, Color::WHITE);  // Highlight
          }

          // Agent type text - LARGE
          std::string line1 = msg.substr(0, msg.find('\n'));
          if (line1.length() > 22) line1 = line1.substr(0, 22);
          it.print(120, 60, id(font_body), PURPLE, TextAlign::CENTER, line1.c_str());

          // Description - USE BODY FONT for readability
          std::string line2 = "";
          if (msg.find('\n') != std::string::npos) {
              line2 = msg.substr(msg.find('\n') + 1);
              if (line2.length() > 24) {
                  // Scroll long descriptions
                  int scroll = (sub_frame / 2) % (line2.length() - 22);
                  line2 = line2.substr(scroll, 24);
              }
          }
          it.print(120, 85, id(font_body), Color(150, 150, 150), TextAlign::CENTER, line2.c_str());

          // Working indicator at bottom
          std::string dots = "";
          for (int i = 0; i < (sub_frame / 6) % 4; i++) dots += ".";
          it.print(120, 110, id(font_body), PINK, TextAlign::CENTER, ("Working" + dots).c_str());

          return;
      }

      // === AGENT_PLAN MODE - Planning/todos with real items ===
      if (mode == "AGENT_PLAN") {
          int plan_frame = (millis() / 200) % 10;

          // Amber header bar
          it.filled_rectangle(0, 0, 240, 22, AMBER);
          it.print(120, 4, id(font_body), Color::BLACK, TextAlign::TOP_CENTER, "PLANNING");

          // Parse message into lines: header, count, then todo items
          std::vector<std::string> lines;
          std::string current = "";
          for (char c : msg) {
              if (c == '\n') {
                  if (!current.empty()) lines.push_back(current);
                  current = "";
              } else if (c >= 32 && c <= 126) {
                  current += c;
              }
          }
          if (!current.empty()) lines.push_back(current);

          // Dark content area
          it.filled_rectangle(5, 26, 230, 90, Color(20, 20, 15));
          it.rectangle(5, 26, 230, 90, Color(100, 80, 30));

          // Display todo items (skip first 2 lines which are header/count)
          int y = 32;
          for (size_t i = 2; i < lines.size() && i < 5; i++) {
              std::string item = lines[i];
              bool is_active = (item.length() > 0 && item[0] == '>');  // ► becomes >

              // Checkbox
              int box_x = 15;
              if (is_active) {
                  // Filled checkbox for active item
                  it.filled_rectangle(box_x, y + 2, 14, 14, LIME);
                  it.print(box_x + 4, y + 2, id(font_body), Color::BLACK, TextAlign::TOP_LEFT, ">");
              } else {
                  // Empty checkbox for pending
                  it.rectangle(box_x, y + 2, 14, 14, AMBER);
              }

              // Item text (skip the marker character)
              std::string text = item;
              if (text.length() > 2) text = text.substr(2);  // Skip "► " or "○ "
              if (text.length() > 24) text = text.substr(0, 24);

              Color text_color = is_active ? LIME : Color(180, 160, 120);
              it.print(35, y + 2, id(font_body), text_color, TextAlign::TOP_LEFT, text.c_str());

              y += 22;
          }

          // Bottom status: "X more pending"
          if (lines.size() > 1) {
              it.print(120, 118, id(font_body), Color(120, 100, 60), TextAlign::CENTER, lines[1].c_str());
          }

          return;
      }

      // === AGENT_READ MODE - Reading file ===
      if (mode == "AGENT_READ") {
          int read_frame = (millis() / 50) % 40;

          // Blue header bar
          Color READ_BLUE = Color(80, 130, 220);
          it.filled_rectangle(0, 0, 240, 22, READ_BLUE);
          it.print(120, 4, id(font_body), Color::WHITE, TextAlign::TOP_CENTER, "READING");

          // Page/document visual with scrolling text lines
          it.filled_rectangle(30, 28, 180, 75, Color(15, 20, 30));
          it.rectangle(30, 28, 180, 75, Color(60, 100, 180));

          for (int i = 0; i < 5; i++) {
              int y = 35 + i * 13;
              int offset = (read_frame + i * 4) % 25;
              int width = 120 + (offset * 2) - (i * 8);
              if (width > 160) width = 160;
              if (width < 50) width = 50;
              int alpha = 220 - i * 35;
              Color line_color = Color(40 * alpha / 255, 80 * alpha / 255, 160 * alpha / 255);
              it.filled_rectangle(40, y, width, 7, line_color);
          }

          // File name - USE BODY FONT, prominent
          std::string filename = msg;
          if (filename.length() > 24) filename = ".." + filename.substr(filename.length() - 22);
          it.print(120, 110, id(font_body), READ_BLUE, TextAlign::CENTER, filename.c_str());

          return;
      }

      // === AGENT MODE - Claude Code is working (background agents, generic tasks) ===
      if (mode == "AGENT") {
          int code_frame = (millis() / 80) % 40;  // Fast animation

          // Cyan header bar
          it.filled_rectangle(0, 0, 240, 22, CYAN);
          it.print(120, 4, id(font_body), Color::BLACK, TextAlign::TOP_CENTER, "WORKING");

          // Matrix-style falling code effect (in background)
          for (int col = 0; col < 12; col++) {
            int offset = (col * 7 + code_frame * 3) % 40;
            for (int row = 0; row < 5; row++) {
              int y = 25 + (row * 20 + offset) % 90;
              int brightness = 180 - (row * 30);
              if (brightness < 40) brightness = 40;
              Color code_color = Color(0, brightness, brightness / 2);
              int char_w = 3 + ((col + row + code_frame) % 4);
              it.filled_rectangle(20 + col * 18, y, char_w, 7, code_color);
            }
          }

          // Parse message for tool info
          std::string line1 = msg;
          std::string line2 = "";
          size_t nl = msg.find('\n');
          if (nl != std::string::npos) {
              line1 = msg.substr(0, nl);
              line2 = msg.substr(nl + 1);
          }

          // Semi-transparent overlay for text readability
          it.filled_rectangle(15, 45, 210, 55, Color(0, 20, 25));
          it.rectangle(15, 45, 210, 55, CYAN);

          // Main status - what's happening
          if (!line1.empty() && line1 != "CLAWDBOT READY") {
              if (line1.length() > 22) line1 = line1.substr(0, 22);
              it.print(120, 52, id(font_body), CYAN, TextAlign::CENTER, line1.c_str());
          } else {
              it.print(120, 52, id(font_body), CYAN, TextAlign::CENTER, "Agent Active");
          }

          // Detail line - USE BODY FONT for readability
          if (!line2.empty()) {
              if (line2.length() > 24) {
                  // Scroll long text
                  int scroll = (code_frame / 3) % (line2.length() - 22);
                  line2 = line2.substr(scroll, 24);
              }
              it.print(120, 76, id(font_body), Color(100, 160, 160), TextAlign::CENTER, line2.c_str());
          } else {
              it.print(120, 76, id(font_body), Color(80, 120, 120), TextAlign::CENTER, "Processing...");
          }

          // Bouncing dots at bottom for activity indicator
          Color dot_colors[] = {CYAN, TEAL, LIME, CYAN};
          for (int i = 0; i < 4; i++) {
              int bounce = abs(((code_frame + i * 8) % 24) - 12) / 3;
              int x = 90 + i * 20;
              it.filled_circle(x, 115 - bounce, 5, dot_colors[i]);
          }

          return;
      }

      // === LOADING MODE - Clean minimal loading indicator ===
      if (mode == "LOADING") {
          int load_frame = (millis() / 80) % 40;

          // Simple message at top
          it.print(120, 30, id(font_body), Color(150, 150, 160), TextAlign::CENTER, msg.c_str());

          // Minimal animated dots - just 3 cycling dots
          for (int i = 0; i < 3; i++) {
              int alpha = 60;
              // One dot is bright at a time, cycles through
              if (i == (load_frame / 13) % 3) {
                  alpha = 255;
              }
              Color dot_c = Color(alpha, alpha, alpha + 20);
              it.filled_circle(100 + i * 20, 70, 4, dot_c);
          }

          return;
      }

      // === BRIEFING MODE - Colorful status update display ===
      if (mode == "BRIEFING") {
          int brief_frame = (millis() / 150) % 20;

          // Gradient header bar - teal to cyan
          for (int i = 0; i < 24; i++) {
              int r = 0;
              int g = 180 + (i * 3);
              int b = 200 + (i * 2);
              if (g > 255) g = 255;
              if (b > 255) b = 255;
              it.line(0, i, 240, i, Color(r, g, b));
          }
          it.print(120, 5, id(font_body), Color::BLACK, TextAlign::TOP_CENTER, "STATUS UPDATE");

          // Parse message into lines
          std::vector<std::string> lines;
          std::string current = "";
          for (char c : msg) {
              if (c == '\n') {
                  if (!current.empty()) lines.push_back(current);
                  current = "";
              } else if (c >= 32 && c <= 126) {
                  current += c;
              }
          }
          if (!current.empty()) lines.push_back(current);

          // Content box with subtle border
          it.filled_rectangle(8, 28, 224, 70, Color(15, 25, 30));
          it.rectangle(8, 28, 224, 70, TEAL);

          // Content lines with word wrap
          int y = 34;
          for (size_t i = 0; i < lines.size() && i < 3; i++) {
              std::string line = lines[i];
              if (line.length() > 28) line = line.substr(0, 28);
              it.print(120, y, id(font_body), Color::WHITE, TextAlign::CENTER, line.c_str());
              y += 20;
          }

          // Action buttons - colorful and clear
          // A = More (cyan, left)
          it.filled_rectangle(15, 105, 100, 25, CYAN);
          it.print(65, 110, id(font_body), Color::BLACK, TextAlign::CENTER, "A = MORE");

          // B = Done (coral, right)
          it.filled_rectangle(125, 105, 100, 25, CORAL);
          it.print(175, 110, id(font_body), Color::BLACK, TextAlign::CENTER, "B = DONE");

          return;
      }

      // === IDLE / HOME SCREEN - Static, clean display ===
      if (mode == "IDLE" || msg == "CLAWDBOT READY" || msg.empty()) {
          // Solid dark background - no animation
          it.fill(Color(10, 15, 25));

          // Top status bar
          it.filled_rectangle(0, 0, 240, 18, Color(0, 30, 40));

          // Battery icon (always visible, left side)
          if (id(battery_level).has_state()) {
              float batt = id(battery_level).state;
              Color batt_color = (batt > 50) ? LIME : ((batt > 20) ? AMBER : RED);

              // Battery outline
              it.rectangle(8, 4, 28, 10, batt_color);
              it.filled_rectangle(36, 6, 2, 6, batt_color);  // Nub

              // Battery fill
              int fill = (int)(batt / 100.0 * 24);
              it.filled_rectangle(10, 6, fill, 6, batt_color);

              // Percentage
              it.printf(42, 4, id(font_small), batt_color, "%.0f%%", batt);
          }

          // Connection indicator (right side) - solid green, no pulse
          it.filled_circle(225, 9, 4, LIME);

          // Large clock - CYAN colored for visibility
          it.strftime(120, 45, id(font_large), CYAN, TextAlign::CENTER, "%H:%M", id(sntp_time).now());

          // Date - coral accent
          it.strftime(120, 88, id(font_body), CORAL, TextAlign::CENTER, "%a %b %d", id(sntp_time).now());

          // Weather (if available) or hint
          std::string weather = id(weather_display).state;
          if (!weather.empty()) {
              if (weather.length() > 26) weather = weather.substr(0, 26);
              it.print(120, 112, id(font_body), TEAL, TextAlign::CENTER, weather.c_str());
          } else {
              it.print(120, 112, id(font_small), Color(60, 80, 100), TextAlign::CENTER, "Tap A for status");
          }

          return;
      }

      // === ALERT MODE - Red urgency ===
      if (mode == "ALERT") {
          // Flashing red header
          Color header_color = id(pulse_state) ? RED : ORANGE;
          it.filled_rectangle(0, 0, 240, 28, header_color);
          it.print(120, 6, id(font_body), Color::WHITE, TextAlign::TOP_CENTER, "! ALERT !");

          // Message in white on dark
          std::string clean_msg = "";
          for (char c : msg) {
            if (c == '\n' || (c >= 32 && c <= 126)) clean_msg += c;
          }

          std::vector<std::string> lines;
          size_t start = 0, end;
          while ((end = clean_msg.find('\n', start)) != std::string::npos) {
              lines.push_back(clean_msg.substr(start, end - start));
              start = end + 1;
          }
          lines.push_back(clean_msg.substr(start));

          int y = 45;
          for (const auto& line : lines) {
              if (line.empty()) { y += 12; continue; }
              it.print(120, y, id(font_body), Color::WHITE, TextAlign::CENTER, line.c_str());
              y += 22;
          }
          return;
      }

      // === RESPONSE MODE - Clean with coral accent ===
      // Header bar with time and battery
      it.filled_rectangle(0, 0, 240, 22, Color(20, 20, 30));
      it.line(0, 22, 240, 22, CORAL);
      it.strftime(8, 4, id(font_small), DIM, TextAlign::TOP_LEFT, "%H:%M", id(sntp_time).now());
      it.print(120, 4, id(font_small), CORAL, TextAlign::TOP_CENTER, "CLAWDBOT");

      if (id(battery_level).has_state()) {
        it.printf(232, 4, id(font_small), DIM, TextAlign::TOP_RIGHT, "%.0f%%", id(battery_level).state);
      }

      // Sanitize and display message
      std::string clean_msg = "";
      for (char c : msg) {
        if (c == '\n' || (c >= 32 && c <= 126)) clean_msg += c;
      }

      std::vector<std::string> lines;
      size_t start = 0, end;
      while ((end = clean_msg.find('\n', start)) != std::string::npos) {
          lines.push_back(clean_msg.substr(start, end - start));
          start = end + 1;
      }
      lines.push_back(clean_msg.substr(start));

      // Center content vertically
      int y = (lines.size() > 4) ? 28 : ((lines.size() > 2) ? 40 : 55);
      for (const auto& line : lines) {
          if (line.empty()) { y += 12; continue; }
          it.print(120, y, id(font_body), Color::WHITE, TextAlign::CENTER, line.c_str());
          y += 22;
      }

font:
  - file: "gfonts://Roboto Mono"
    id: font_large
    size: 38
  - file: "gfonts://Roboto Mono"
    id: font_body
    size: 16
  - file: "gfonts://Roboto Mono"
    id: font_small
    size: 10
